# Point Cloud Processing{#processing}

In this section we'll process the [raw point cloud data](#data_desc) using [`cloud2trees`](https://github.com/georgewoolsey/cloud2trees) developed to provide accessible routines for processing point cloud data collected by airborne lidar or generated using UAS imagery and photogrammetry (e.g. structure from motion).

The `cloud2trees` package can be installed by following the directions listed in the [README file on GitHub](https://github.com/georgewoolsey/cloud2trees). If one is still experiencing difficulties installing the package, see the [example.R file](https://github.com/georgewoolsey/cloud2trees/blob/main/inst/examples/example.R) which details how to install the package using a virgin R instance.

```{r, eval=FALSE}
## remotes helps us get packages hosted on github
install.packages("remotes")
## get cloud2trees
remotes::install_github(repo = "georgewoolsey/cloud2trees", upgrade = F)
```

Load the standard libraries we use to do work

```{r, warning=FALSE, message=FALSE}
# bread-and-butter
library(tidyverse) # the tidyverse
library(viridis) # viridis colors
library(harrypotter) # hp colors
library(RColorBrewer) # brewer colors
library(scales) # work with number and plot scales
library(latex2exp)

# visualization
library(mapview) # interactive html maps
library(kableExtra) # tables
library(patchwork) # combine plots

# spatial analysis
library(terra) # raster
library(sf) # simple features
library(lidR) # lidar data
library(cloud2trees) # the cloud2trees
```

```{r, include=F, warning=F, message=F}
# knit options
knitr::opts_chunk$set(
  echo = TRUE
  , warning = FALSE
  , message = FALSE
  # , results = 'hide'
  , fig.width = 10.5
  , fig.height = 7
)
# option to put satellite imagery as base layer of mapview maps
  mapview::mapviewOptions(
    homebutton = FALSE
    # , basemaps = c("Esri.WorldImagery","OpenStreetMap")
    , basemaps = c("OpenStreetMap", "Esri.WorldImagery")
  )
# clean session
remove(list = ls())
gc()
```

## Data Location

Let's check out the location of the data we got

```{r}
# directory with the downloaded .las|.laz files
f <- "d:/BLM_CO_SWDF_DawsonFuelsTreatment/Final/PointCloud/Tiles"
# f <- "d:/BLM_CO_SWDF_DawsonFuelsTreatment/Final/PointCloud/Full/"
# is there data?
list.files(f, pattern = ".*\\.(laz|las)$") %>% length()
# what files are in here?
list.files(f, pattern = ".*\\.(laz|las)$")[1:3]
```

what information does `lidR` read from the catalog?

```{r}
ctg_temp <- lidR::readLAScatalog(f)
ctg_temp
```

that's a lot of points...can an ordinary laptop handle it? we'll find out.

We'll plot our point cloud data tiles real quick

```{r}
ctg_temp@data %>%
  dplyr::mutate(
    nm =
      basename(filename) %>%
      stringr::str_remove("\\.[^.]+$") %>%
      stringr::str_remove("BLM_CO_SWDF_DawsonFuelsTreatment_PointCloud_")
  ) %>%
  ggplot2::ggplot() + 
  ggplot2::geom_sf(fill=NA, color = "red") +
  ggplot2::theme_light()
```

oh no. something weird is going on with the location of these point cloud tiles...perhaps that's the reason for the "0 points/m2" message from `lidR` above

no worries, `cloud2trees` has built-in functionality to handle corrupt point cloud data. let's see if that functionality can help clean this up

```{r}
ctg_temp %>% 
  cloud2trees:::check_las_ctg_empty() %>% 
  purrr::pluck("data") %>% 
  dplyr::mutate(
    nm =
      basename(filename) %>%
      stringr::str_remove("\\.[^.]+$") %>%
      stringr::str_remove("BLM_CO_SWDF_DawsonFuelsTreatment_PointCloud_")
  ) %>%
  ggplot2::ggplot() + 
    ggplot2::geom_sf(fill=NA, color = "red") +
    ggplot2::geom_sf_label(mapping = ggplot2::aes(label = nm),size=2) +
    ggplot2::theme_void()
```

that's better. let's look at this on a map to orient ourselves

```{r}
ctg_temp %>% 
  cloud2trees:::check_las_ctg_empty() %>% 
  purrr::pluck("data") %>% 
  mapview::mapview(popup = F, layer.name = "point cloud tile")
```

## Point Cloud to Raster: `cloud2raster()`

Although the `cloud2trees::cloud2trees()` function combines methods in the `cloud2trees` package for an all-in-one approach, we'll instead use the `cloud2trees::cloud2raster()` function to generate a CHM from the point cloud that we can work with to perform both individual tree detection and slash pile identification (discussed later).

We'll set the options in the function to generate a CHM which represents a DSM with the ground removed and no other filtering. This high resolution (i.e. fine-grain) CHM will serve as the foundation for tree detection and slash pile detection as we can manipulate it to optimize the processing for both methods.

```{r}
# outdir
c2t_output_dir <- "../data"
c2t_process_dir <- file.path(c2t_output_dir, "point_cloud_processing_delivery")
c2t_tracking_fnm <- file.path(c2t_process_dir, "processed_tracking_data.csv")
##############################################################
# cloud2trees::cloud2raster
##############################################################
if(
  !file.exists( file.path(c2t_process_dir, "chm_0.1m.tif") )
  || !file.exists( file.path(c2t_process_dir, "dtm_0.25m.tif") )
){
  # time it
  st_temp <- Sys.time()
  # run it
  # cloud2trees
  cloud2raster_ans <- cloud2trees::cloud2raster(
    output_dir = c2t_output_dir
    , input_las_dir = f
    , accuracy_level = 2
    , keep_intrmdt = T
    , dtm_res_m = 0.25
    , chm_res_m = 0.1
    , min_height = 0 # effectively generates a DSM based on non-ground points
  )
  
  # timer
  mins_temp <- difftime(Sys.time(),st_temp,units = "mins") %>% as.numeric()
  # save tracking
  dplyr::tibble(
    timer_cloud2raster_mins = mins_temp
  ) %>% 
    write.csv(
      file = c2t_tracking_fnm
      , row.names = F, append = F
    )
}else{
  dtm_temp <- terra::rast( file.path(c2t_process_dir, "dtm_0.25m.tif") )
  chm_temp <- terra::rast( file.path(c2t_process_dir, "chm_0.1m.tif") )
  
  cloud2raster_ans <- list(
    "dtm_rast" = dtm_temp
    , "chm_rast" = chm_temp
  )
}
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
remove(f)
gc()
```

let's see what we got from `cloud2trees::cloud2raster()`

```{r}
cloud2raster_ans %>% names()
```

there's a DTM

```{r}
# plot to check out the fine-resolution DTM raster
cloud2raster_ans$dtm_rast %>% 
  terra::plot(col = harrypotter::hp(n=100, option = "mischief"), main = "DTM (m)")
```

there's a CHM

```{r}
# plot to check out the fine-resolution CHM raster
cloud2raster_ans$chm_rast %>% 
  terra::plot(col = viridis::plasma(n=100), main = "CHM (m)")
```

let's see some details about the CHM

```{r}
# what chm?
cloud2raster_ans$chm_rast
# what data?
cloud2raster_ans$chm_rast %>% terra::summary()
```

for tree detection, we'll aggregate the CHM to a lower resolution (i.e. coarser) to smooth out some of the fine detail that can increase the noise in the tree detection processing. This aggregation process also will speed up the processing and reduce the chances of computational memory issues.

```{r}
##################################################################
# aggregate to make raster more coarse for tree detection
##################################################################
# first, we'll borrow from the `cloud2trees` codebase to get a function to change the resolution of a raster exactly
###___________________________________________###
# adjust the resolution of a raster to be in exactly the target resolution
###___________________________________________###
if(
  !file.exists( file.path(c2t_process_dir, "chm_0.25m.tif") )
){
  agg_chm_rast <- cloud2trees:::adjust_raster_resolution(
    cloud2raster_ans$chm_rast
    , target_resolution = 0.25
    , fun = max
    , resample_method = "max"
    , ofile = file.path(c2t_process_dir, "chm_0.25m.tif")
  )
}else{
  agg_chm_rast <- terra::rast( file.path(c2t_process_dir, "chm_0.25m.tif") )
}
# what chm?
agg_chm_rast
# what data?
agg_chm_rast %>% terra::summary()
```

## Individial Tree Detection Tuning: `itd_tuning()`{#itd}

The `cloud2trees` package performs individual tree detection using `lidR::locate_trees()` with the `lidR::lmf()` algorithm. The local maximum filter algorithm allows for a constant window size or a variable window size defined by a function. See the `lidR` [package book section](https://r-lidar.github.io/lidRbook/itd.html) by point cloud processing expert [Jean-Romain Roussel](https://github.com/Jean-Romain) for excellent detail on ITD and defining window size.

The `itd_tuning()` function is used to visually assess tree crown delineation results from different window size functions used for the detection of individual trees. `itd_tuning()` allows users to test different window size functions on a sample of data to determine which function is most suitable for the area being analyzed. The preferred function can then be used in the `ws` parameter in `raster2trees()` and `cloud2trees()`.

Let's run `itd_tuning()` on our CHM data starting with default window size functions

```{r}
###___________________________________________###
# itd_tuning
###___________________________________________###
# run it
set.seed(99)
itd_tuning_ans <- cloud2trees::itd_tuning(
  input_chm_rast = agg_chm_rast
  , min_height = 1.37
  , n_samples = 2
)
# huh?
itd_tuning_ans %>% names()
```

plot the detected trees on the CHM

```{r, fig.height=6, fig.width=7}
itd_tuning_ans$plot_samples
ggplot2::ggsave(
  filename = file.path(c2t_process_dir, "itd_tuning_plot_samples.jpg")
  , plot = itd_tuning_ans$plot_samples
  , height = 7, width = 7
  , dpi = "print"
)
```

plot the summary of the detected trees

```{r, fig.height=7, fig.width=8.3}
itd_tuning_ans$plot_sample_summary
ggplot2::ggsave(
  filename = file.path(c2t_process_dir, "itd_tuning_plot_sample_summary.jpg")
  , plot = itd_tuning_ans$plot_sample_summary
  , height = 7, width = 9.5
  , dpi = "print"
)  
```

the `exp_fn` results in too few trees with crown diameters generally similar to the total tree height which is not expected

check the `ws_fn_list` return which includes the different window size functions tested

```{r}
# what ws_fn_list
itd_tuning_ans$ws_fn_list %>% str()
```

let's look at the function definition for the linear function (`lin_fn`)

```{r}
# the linear function
itd_tuning_ans$ws_fn_list$lin_fn
```

let's plot all of the functions we tested with our call to `itd_tuning()` using the defaults

```{r}
# shape of the ws functions
plt_ws_fn <- ggplot2::ggplot() +
  ggplot2::geom_function(mapping=ggplot2::aes(color = "lin_fn"),fun=itd_tuning_ans$ws_fn_list$lin_fn, lwd=1.2) +
  ggplot2::geom_function(mapping=ggplot2::aes(color = "log_fn"),fun=itd_tuning_ans$ws_fn_list$log_fn, lwd=1.2) +
  ggplot2::geom_function(mapping=ggplot2::aes(color = "exp_fn"),fun=itd_tuning_ans$ws_fn_list$exp_fn, lwd=1.2) +
  ggplot2::xlim(-5,35) +
  ggplot2::scale_color_manual( values = c(viridis::viridis(3), "gray") ) +
  ggplot2::labs(x = "heights", y = "ws", color = "ws function") +
  ggplot2::theme_light()
plt_ws_fn
```

Let's define our own custom linear function that slightly decreases the window size for the shortest trees but increases the window for taller trees compared to the default linear function.

```{r}
my_lin_fn <- function (x) {
      y <- dplyr::case_when(
        is.na(x) ~ 0.001
        , x < 0 ~ 0.001
        , x > (5.3-0.51)/0.21 ~ 5.3
        , TRUE ~ 0.51 + (x * 0.21)
      )
      return(y)
  }
# plt
plt_ws_fn +
  ggplot2::geom_function(
    fun = my_lin_fn
    , mapping = ggplot2::aes(color = "my_lin_fn")
    , lwd = 2
  )
```

We'll run another sample test using `itd_tuning()`with our new function

```{r}
itd_tuning_ans2 <- cloud2trees::itd_tuning(
  input_chm_rast = agg_chm_rast
  , min_height = 1.37
  , ws_fn_list = list(
    lin_fn = itd_tuning_ans$ws_fn_list$lin_fn
    , log_fn = itd_tuning_ans$ws_fn_list$log_fn
    , my_lin_fn = my_lin_fn
  )
)
```

plot the detected trees on the CHM

```{r, fig.height=6, fig.width=7}
itd_tuning_ans2$plot_samples
ggplot2::ggsave(
  filename = file.path(c2t_process_dir, "itd_tuning_plot_samples2.jpg")
  , plot = itd_tuning_ans2$plot_samples
  , height = 7, width = 7
  , dpi = "print"
)
```

plot the summary of the detected trees

```{r, fig.height=7, fig.width=8.3}
itd_tuning_ans2$plot_sample_summary
ggplot2::ggsave(
  filename = file.path(c2t_process_dir, "itd_tuning_plot_sample_summary2.jpg")
  , plot = itd_tuning_ans2$plot_sample_summary
  , height = 7, width = 9.5
  , dpi = "print"
)
```

notice, there is also a tree crown data frame in the return

```{r}
# what?
itd_tuning_ans2$crowns %>% dplyr::glimpse()
# count trees by sample
itd_tuning_ans2$crowns %>% sf::st_drop_geometry() %>% dplyr::count(sample_number, ws_fn)
```

with the crowns data we can explore alternative visualizations including overlaying the detected trees on the RGB data if available

```{r}
#### read RGB data keep only RGB
pj_rgb_rast <- terra::rast("d:/BLM_CO_SWDF_DawsonFuelsTreatment/Final/Ortho/BLM_CO_SWDF_DawsonFuelsTreatment_Ortho_202504.tif") %>% 
  terra::subset(c(1,2,3))
# make a function to plot these detected crowns with rgb data
plt_rgb_rast_itd_crowns <- function(sample_nmbr = 1, rgb_rast, itd_crowns, plt_lwd = 0.7) {
  # crop
  crp_rgb_rast_temp <- rgb_rast %>% 
    terra::crop(
      itd_crowns %>% 
        dplyr::ungroup() %>% 
        dplyr::filter(sample_number == sample_nmbr) %>% 
        sf::st_union() %>% 
        sf::st_bbox() %>% 
        sf::st_as_sfc() %>% 
        sf::st_buffer(0.2) %>% 
        sf::st_transform(terra::crs(rgb_rast)) %>% 
        terra::vect()
    )
  # convert raster to a data frame and create hex colors
  # ?grDevices::rgb
  rgb_df_temp <-
    crp_rgb_rast_temp %>% 
    terra::as.data.frame(xy = TRUE) %>%
    dplyr::rename(
      red = 3, green = 4, blue = 5
    ) %>% 
    dplyr::mutate(
      hex_col = grDevices::rgb(
        red
        , green
        , blue
        , maxColorValue = 255
      )
    )
    # dplyr::glimpse()
  
  # plt
  plt <- ggplot2::ggplot() +
    # add rgb base map
    ggplot2::geom_raster(data = rgb_df_temp, mapping = ggplot2::aes(x = x, y = y, fill = hex_col)) +
    # use identity scale so the hex codes are used directly
    ggplot2::scale_fill_identity() +
    # overlay polygons
    # ggplot2::geom_sf(data = polys, fill = NA, color = "red", linewidth = 0.5) +
    ggplot2::geom_sf(
      data = itd_crowns %>% 
        dplyr::filter(sample_number==sample_nmbr) %>% 
        cloud2trees::simplify_multipolygon_crowns() %>% 
        sf::st_make_valid() %>% 
        dplyr::filter(sf::st_is_valid(.)) %>% 
        sf::st_transform(terra::crs(crp_rgb_rast_temp))
      , mapping = ggplot2::aes(color = ws_fn)
      , fill = NA
      , lwd = plt_lwd
      , inherit.aes = F
    ) +
    ggplot2::facet_grid(cols = dplyr::vars(ws_fn)) +
    ggplot2::scale_color_viridis_d(name = "") +
    ggplot2::coord_sf(expand = F) +
    ggplot2::theme_void() +
    ggplot2::theme(
      legend.position = "none"
      , strip.text = ggplot2::element_text(face = "bold", color = "black", margin = ggplot2::margin(t = 4, b = 4))
      , strip.background = ggplot2::element_rect(fill = "gray88", color = "gray88")
      , panel.spacing = ggplot2::unit(1,"lines")
    )
  return(plt)
}
```

plot the trees detected in sample one on the RGB

```{r, fig.height=5.5, fig.width=7.2}
plt_rgb_rast_itd_crowns(sample_nmbr = 1, rgb_rast = pj_rgb_rast, itd_crowns = itd_tuning_ans2$crowns)
```

```{r, include=FALSE, eval=FALSE}
### building the plt_rgb_rast_itd_crowns fn
  crp_rgb_rast_temp <- pj_rgb_rast %>% 
    terra::crop(
      itd_tuning_ans2$crowns %>% 
        dplyr::ungroup() %>% 
        dplyr::filter(sample_number == 1) %>% 
        sf::st_union() %>% 
        sf::st_bbox() %>% 
        sf::st_as_sfc() %>% 
        sf::st_buffer(0.5) %>% 
        sf::st_transform(terra::crs(pj_rgb_rast)) %>% 
        terra::vect()
    )
  crp_chm_rast_temp <- agg_chm_rast %>% 
    terra::crop(
      itd_tuning_ans2$crowns %>% 
        dplyr::ungroup() %>% 
        dplyr::filter(sample_number == 1) %>% 
        sf::st_union() %>% 
        sf::st_bbox() %>% 
        sf::st_as_sfc() %>% 
        sf::st_buffer(0.5) %>% 
        sf::st_transform(terra::crs(agg_chm_rast)) %>% 
        terra::vect()
    )
  # ?terra::plotRGB
  # ?terra::ifel
  terra::plotRGB(crp_rgb_rast_temp, stretch = "lin", axes = F)
  terra::plot(
    crp_chm_rast_temp
    # terra::ifel(crp_chm_rast_temp<1.37,NA,crp_chm_rast_temp)
    , add = T
    , col = viridis::plasma(100), alpha = 0.3
    , legend = F
    , axes = F
  )
  terra::plot(
    itd_tuning_ans2$crowns %>%
      cloud2trees::simplify_multipolygon_crowns() %>%
      dplyr::ungroup() %>%
      dplyr::filter(sample_number == 1 & ws_fn == "my_lin_fn") %>%
      sf::st_transform(terra::crs(rgb_rast_temp)) %>%
      terra::vect()
    , add = T, border = "brown", col = NA, lwd = 1.6
  )
  terra::plot(
    itd_tuning_ans2$crowns %>%
      cloud2trees::simplify_multipolygon_crowns() %>%
      dplyr::ungroup() %>%
      dplyr::filter(sample_number == 1 & ws_fn == "lin_fn") %>%
      sf::st_transform(terra::crs(rgb_rast_temp)) %>%
      terra::vect()
    , add = T, border = "gold", col = NA, lwd = 1.2
  )
  terra::plot(
    itd_tuning_ans2$crowns %>%
      cloud2trees::simplify_multipolygon_crowns() %>%
      dplyr::ungroup() %>%
      dplyr::filter(sample_number == 1 & ws_fn == "log_fn") %>%
      sf::st_transform(terra::crs(rgb_rast_temp)) %>%
      terra::vect()
    , add = T, border = "navy", col = NA, lwd = 0.8
  )
  
  xxx <-
    itd_tuning_ans2$crowns %>%
      dplyr::ungroup() %>%
      cloud2trees::simplify_multipolygon_crowns() %>%
      sf::st_make_valid() %>%
      dplyr::filter(sample_number == 1 & ws_fn == "my_lin_fn")

  mapview::mapview(xxx, zcol = "tree_height_m")
  remove(xxx)
  gc()
  
  ctg_temp <- lidR::readLAScatalog(
    file.path(c2t_output_dir, "point_cloud_processing_temp", "02_normalize")
  )
  las_temp <- lidR::clip_roi(
    ctg_temp
    , itd_tuning_ans2$crowns %>%
      dplyr::ungroup() %>%
      cloud2trees::simplify_multipolygon_crowns() %>%
      sf::st_make_valid() %>%
      dplyr::filter(sample_number == 1 & ws_fn == "my_lin_fn") %>%
      dplyr::filter(
        # treeID %in% c("68_708803.7_4193239.3", "67_708804.9_4193239.9" , "69_708804.9_4193237.9", "66_708803.9_4193240.3")
        # treeID %in% c("6_708811.3_4193258.3")
        treeID %in% c("71_708809.1_4193235.3", "76_708807.3_4193233.9", "72_708805.5_4193234.7")
      ) %>%
      sf::st_union() %>%
      sf::st_buffer(1) %>%
      sf::st_transform(lidR::st_crs(ctg_temp))
  )
  las_temp
  lidR::plot(
    las_temp, color = "RGB", bg = "white", legend = F
  )
  lidR::plot(
    las_temp, color = "Z", bg = "white", legend = T
  )
  
  # convert raster to a data frame and create hex colors
  # ?grDevices::rgb
  rgb_df_temp <-
    crp_rgb_rast_temp %>% 
    terra::as.data.frame(xy = TRUE) %>%
    dplyr::rename(
      red = 3, green = 4, blue = 5
    ) %>% 
    dplyr::mutate(
      hex_col = grDevices::rgb(
        red
        , green
        , blue
        , maxColorValue = 255
      )
    )
    # dplyr::glimpse()
  
  # plt
  ggplot2::ggplot() +
    # add rgb base map
    ggplot2::geom_raster(data = rgb_df_temp, mapping = ggplot2::aes(x = x, y = y, fill = hex_col)) +
    # use identity scale so the hex codes are used directly
    ggplot2::scale_fill_identity() +
    # overlay polygons
    # ggplot2::geom_sf(data = polys, fill = NA, color = "red", linewidth = 0.5) +
    ggplot2::geom_sf(
      data = itd_tuning_ans2$crowns %>% 
        dplyr::filter(sample_number==1) %>% 
        sf::st_transform(terra::crs(crp_rgb_rast_temp))
      , mapping = ggplot2::aes(color = ws_fn)
      , fill = NA
      , lwd = 0.8
      , inherit.aes = F
    ) +
    ggplot2::facet_grid(cols = dplyr::vars(ws_fn)) +
    ggplot2::scale_color_viridis_d(name = "") +
    ggplot2::coord_sf(expand = F) +
    ggplot2::theme_void() +
    ggplot2::theme(
      legend.position = "none"
      , strip.text = ggplot2::element_text(face = "bold", color = "black", margin = ggplot2::margin(t = 4, b = 4))
      , strip.background = ggplot2::element_rect(fill = "gray88", color = "gray88")
      , panel.spacing = ggplot2::unit(1,"lines")
    )
  
  
  remove(list = ls()[grep("_temp",ls())])
  gc()
```

this is only moderately helpful as the tree density in tree clumps is difficult to infer from the 2D aerial imagery alone. let's move forward with the default linear function in the `raster2trees()` function

```{r}
my_ws_fn <- cloud2trees::itd_ws_functions()[["lin_fn"]]
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
remove(itd_tuning_ans, itd_tuning_ans2)
gc()
```

## Tree Extraction: `raster2trees()`{#trees}

Now, perform individual tree detection using `raster2trees()` on the aggregated CHM

```{r}
##############################################################
# cloud2trees::raster2trees
##############################################################
search_temp <- cloud2trees:::search_dir_final_detected(dir = c2t_process_dir)
if(
  is.null(search_temp$crowns_flist)
  || is.null(search_temp$ttops_flist)
){
  # time it
  st_temp <- Sys.time()
  # run it
  # cloud2trees
  raster2trees_ans <- cloud2trees::raster2trees(
    chm_rast = agg_chm_rast
    , outfolder = c2t_process_dir
    , ws = my_ws_fn
    , min_height = 1.37
    , min_crown_area = 0.5
  )
  # raster2trees_ans
  # timer
  mins_temp <- difftime(Sys.time(),st_temp,units = "mins") %>% as.numeric()
  # save tracking
  readr::read_csv(c2t_tracking_fnm, progress = F, show_col_types = F) %>% 
    dplyr::mutate(
      timer_raster2trees_mins = mins_temp
    ) %>% 
    write.csv(
      file = c2t_tracking_fnm
      , row.names = F, append = F
    )
}else{
  search_dir_final_detected_ans_temp <- cloud2trees:::search_dir_final_detected(dir = c2t_process_dir)
  crowns_flist_temp <- search_dir_final_detected_ans_temp$crowns_flist
  # read it to get the full list of tree polygons
    raster2trees_ans <- crowns_flist_temp %>%
      purrr::map(function(x){
        sf::st_read(
          dsn = x
          , quiet = T
        ) %>%
        # throw in hey_xxxxxxxxxx to test it works if we include non-existant columns
        dplyr::select( -dplyr::any_of(c(
          "hey_xxxxxxxxxx"
          , "tree_cbh_m"
          , "is_training_cbh"
        )))
      }) %>%
      dplyr::bind_rows()
}
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

we should have a spatial tree list with tree height and crown dimensions attached

```{r}
raster2trees_ans %>% dplyr::glimpse()
```

That's a lot of trees! Let's plot some on the RGB imagery for the central part of the data. This time, we'll use `terra` plotting to demonstrate

```{r}
aoi_temp <-
  raster2trees_ans %>% 
  dplyr::slice_sample(prop=0.1) %>% 
  sf::st_point_on_surface() %>% 
  sf::st_union() %>% 
  sf::st_bbox() %>% 
  sf::st_as_sfc() %>% 
  sf::st_centroid() %>% 
  sf::st_buffer(22, endCapStyle = "SQUARE")
# rgb
pj_rgb_rast %>% 
  terra::crop(
    aoi_temp %>%
      sf::st_transform(terra::crs(pj_rgb_rast)) %>% 
      terra::vect()
  ) %>% 
  terra::plotRGB(stretch = "lin", axes = F)
# trees
terra::plot(
  raster2trees_ans %>% 
    dplyr::inner_join(
      raster2trees_ans %>% 
        sf::st_intersection(
          aoi_temp %>% sf::st_buffer(-2)
        ) %>% 
        sf::st_drop_geometry() %>% 
        dplyr::select(treeID)
      , by = "treeID"
    ) %>% 
    dplyr::ungroup() %>%
    cloud2trees::simplify_multipolygon_crowns() %>%
    sf::st_transform(terra::crs(pj_rgb_rast)) %>%
    terra::vect()
  , add = T
  , border = "brown", col = NA, lwd = 1.2
)
```

That looks like we did a decent job extracting trees. Remember we set a minimum tree height of 1.37 m (DBH) and we may want to filter out small trees as the analysis proceeds. Let's look at the distribution of tree height in our study area.

```{r}
# there are always tree heights
raster2trees_ans %>%
  ggplot2::ggplot(mapping = ggplot2::aes(x = tree_height_m)) +
  ggplot2::geom_density(fill = "navy", color = "navy", alpha = 0.2) +
  ggplot2::scale_x_continuous(breaks = scales::breaks_extended(11)) +
  ggplot2::labs(x = "tree ht. (m)", y = "") +
  ggplot2::theme_light() +
  ggplot2::theme(axis.text.y = ggplot2::element_blank(), axis.ticks.y = ggplot2::element_blank())
```

let's look at the summary statistics of tree height

```{r}
raster2trees_ans$tree_height_m %>% summary()
```

Notice above we tracked the time it took to process the data. let's see how long those `cloud2trees` processing steps took to run. Run times are, of course, dependent on computer processing and I am working on a laptop typical of a spatial analyst (especially outside of the US Federal Government) running Windows with an Intel i7-10750H 6-core computer processor unit and 32 gigabytes of random-access memory.

```{r}
# load processing extent
raw_las_ctg_info <- file.path(c2t_process_dir,"raw_las_ctg_info.gpkg") %>% 
  sf::st_read(quiet = T) %>% 
  dplyr::mutate(area_m2 = sf::st_area(.) %>% as.numeric())
# load processed_tracking_data.csv
processing_data <- readr::read_csv(
    file = c2t_tracking_fnm
    , progress = F
    , show_col_types = F
  )
# what?
processing_data %>% 
  dplyr::select(timer_cloud2raster_mins, timer_raster2trees_mins) %>%
  dplyr::glimpse()
```

let's do some math

```{r}
# total tree extraction time
trees_mins_temp <- processing_data$timer_cloud2raster_mins[1] + 
  processing_data$timer_raster2trees_mins[1]
# ha
m2_temp <- raw_las_ctg_info %>% 
  sf::st_drop_geometry() %>% 
  dplyr::summarise(
    m2 = sum(area_m2)
  ) %>% 
  dplyr::pull(m2)
# pts
pts_temp <- raw_las_ctg_info %>% 
  sf::st_drop_geometry() %>% 
  dplyr::summarise(
    pts = sum(Number.of.point.records)
  ) %>% 
  dplyr::pull(pts)
# secs per ha
rate_temp <- (trees_mins_temp*60) / (m2_temp/10000)
# point density
dens_temp <- pts_temp / m2_temp
```

Tree extraction over **`r scales::comma((m2_temp/10000), accuracy = 0.1)`** hectares took a total of **`r scales::comma(trees_mins_temp, accuracy = 0.1)`** minutes at processing rate of **`r scales::comma(rate_temp, accuracy = 0.01)`** seconds per hectare on point cloud data with a point density of **`r scales::comma(dens_temp, accuracy = 0.1)`** points per square meter (**`r scales::comma(pts_temp, accuracy = 1)`** points total).

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
remove(my_lin_fn, my_ws_fn, plt_rgb_rast_itd_crowns, raw_las_ctg_info, processing_data, plt_ws_fn, pj_rgb_rast)
gc()
```

## CBH Modeling: `trees_cbh()`

The `trees_cbh()` function uses the tree crown polygons we [delineated from the point cloud](#trees) with the columns `treeID` and `tree_height_m` to attempt to extract crown base height (CBH) directly from the height normalized point cloud using the process outlined in [Viedma et al. (2024)](https://doi.org/10.1111/2041-210X.14427).

We'll attempt to extract CBH for a sample and model the rest based on the data we successfully extracted from the point cloud.

```{r}
cbh_fnm_temp <- file.path(c2t_process_dir, "cbh_data.csv")
# if we don't already have the data, run it
if(!file.exists( cbh_fnm_temp )){
  # sample proportion
  sample_prop_temp <- 0.10
  # time it
  st_temp <- Sys.time()
  # run it
  trees_cbh_ans <- cloud2trees::trees_cbh(
    trees_poly = c2t_process_dir
    , norm_las = file.path(c2t_output_dir, "point_cloud_processing_temp", "02_normalize")
    , tree_sample_prop = sample_prop_temp
    , which_cbh = "lowest"
    , estimate_missing_cbh = TRUE
    , min_vhp_n = 3
    , voxel_grain_size_m = 1
    , dist_btwn_bins_m = 1
    , min_fuel_layer_ht_m = 0.5
    , lad_pct_gap = 25
    , lad_pct_base = 25
    , num_jump_steps = 1
    , min_lad_pct = 10
    , frst_layer_min_ht_m = 0.5
    , force_same_crs = T
  )
  # timer
  mins_temp <- difftime(Sys.time(),st_temp,units = "mins") %>% as.numeric()
  # save cbh
  trees_cbh_ans %>% sf::st_drop_geometry() %>% 
    write.csv(file = cbh_fnm_temp, row.names = F, append = F)
  # save tracking
  readr::read_csv(c2t_tracking_fnm, progress = F, show_col_types = F) %>% 
    dplyr::mutate(
      timer_trees_cbh_mins = mins_temp
      , sttng_cbh_tree_sample_n = as.character(NA)
      , sttng_cbh_tree_sample_prop = sample_prop_temp
    ) %>% 
    write.csv(
      file = c2t_tracking_fnm
      , row.names = F, append = F
    )
  
}else{
  # cbh data
  trees_cbh_ans <- readr::read_csv( cbh_fnm_temp, progress = F, show_col_types = F)
}
```

```{r, include=F, eval=TRUE}
processing_data_temp <- readr::read_csv(c2t_tracking_fnm, progress = F, show_col_types = F)
```

CBH extraction took a total of **`r scales::comma(processing_data_temp$timer_trees_cbh_mins, accuracy = 0.1)`** minutes (**`r scales::comma(processing_data_temp$timer_trees_cbh_mins/60, accuracy = 0.1)`** hours)

We attempted to extract CBH from `r scales::percent(processing_data_temp$sttng_cbh_tree_sample_prop)` of our tree list (`r scales::comma((nrow(trees_cbh_ans)*processing_data_temp$sttng_cbh_tree_sample_prop), accuracy = 1)` trees), let's see our success rate

```{r}
trees_cbh_ans %>% 
  dplyr::count(is_training_cbh) %>% 
  dplyr::mutate(pct = n/sum(n))
```

That equates to a `r scales::percent(nrow(dplyr::filter(trees_cbh_ans,is_training_cbh==T))/(nrow(trees_cbh_ans)*processing_data_temp$sttng_cbh_tree_sample_prop),accuracy=0.1)` CBH extraction success rate....not a great success ;(

all of the records marked as training data had CBH successfully extracted from the point cloud and were used to estimate a height-CBH allometry relationship that is spatially informed using the relative tree location

let's look at the training versus the modeled CBH versus height

```{r}
trees_cbh_ans %>%
  dplyr::slice_sample(n = 11111) %>% 
  dplyr::arrange(is_training_cbh) %>%
  ggplot2::ggplot(mapping = ggplot2::aes(x = tree_height_m, y = tree_cbh_m, color=is_training_cbh)) + 
  ggplot2::geom_point() +
  ggplot2::labs(x = "tree ht. (m)", y = "tree CBH (m)") +
  ggplot2::scale_y_continuous(breaks = scales::extended_breaks(n=12)) +
  ggplot2::scale_x_continuous(breaks = scales::extended_breaks(n=14)) +
  ggplot2::scale_color_viridis_d(alpha = 0.7, name = "is CBH\nfrom cloud?") +
  ggplot2::theme_light()
```

Let's look at the distribution of CBH in our study area

```{r}
trees_cbh_ans %>%
  ggplot2::ggplot(mapping = ggplot2::aes(x = tree_cbh_m)) +
  ggplot2::geom_density(fill = "maroon4", color = "maroon4", alpha = 0.2) +
  ggplot2::scale_x_continuous(breaks = scales::breaks_extended(11)) +
  ggplot2::labs(x = "tree CBH (m)", y = "") +
  ggplot2::theme_light() +
  ggplot2::theme(axis.text.y = ggplot2::element_blank(), axis.ticks.y = ggplot2::element_blank())
```

and look at the summary statistics of CBH

```{r}
trees_cbh_ans$tree_cbh_m %>% summary()
```

we can also look at the spatial distribution of the trees for which CBH was successfully extracted

```{r}
# convert to pts real quick
treetops_sf <- 
  raster2trees_ans %>% 
  sf::st_drop_geometry() %>% 
  sf::st_as_sf(coords = c("tree_x", "tree_y"), crs = sf::st_crs(raster2trees_ans), remove = F) %>% 
  # add on cbh
  dplyr::left_join(
    trees_cbh_ans %>% 
      dplyr::select(treeID, is_training_cbh, tree_cbh_m)
    , by = "treeID"
  )
# plot
treetops_sf %>% 
  dplyr::slice_sample(n = 11111, by = is_training_cbh) %>% 
  ggplot2::ggplot() +
  ggplot2::geom_sf(mapping = ggplot2::aes(color = is_training_cbh)) +
  ggplot2::scale_color_viridis_d(alpha = 0.7, name = "is CBH\nfrom cloud?") +
  ggplot2::theme_void()
```

that is good spatial distribution of the training data

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

## DBH Modeling: `trees_dbh()`

The `trees_dbh()` function uses the [TreeMap](https://www.fs.usda.gov/rds/archive/catalog/RDS-2021-0074) FIA plot data in the area of the tree list to estimate the height-DBH allometry relationship. The height predicting DBH model built from the FIA data is then used to predict DBH based on tree height in the tree list.

```{r}
dbh_fnm_temp <- file.path(c2t_process_dir, "dbh_data.csv")
# if we don't already have the data, run it
if(!file.exists( dbh_fnm_temp )){
  # time it
  st_temp <- Sys.time()
  # run it
  trees_dbh_ans <- cloud2trees::trees_dbh(
    tree_list = treetops_sf
    , boundary_buffer = 2
    , outfolder = c2t_process_dir
  )
  # timer
  mins_temp <- difftime(Sys.time(),st_temp,units = "mins") %>% as.numeric()
  # save dbh
  trees_dbh_ans %>% sf::st_drop_geometry() %>% 
    write.csv(file = dbh_fnm_temp, row.names = F, append = F)
  # save tracking
  readr::read_csv(c2t_tracking_fnm, progress = F, show_col_types = F) %>% 
    dplyr::mutate(
      timer_trees_dbh_mins = mins_temp
    ) %>% 
    write.csv(
      file = c2t_tracking_fnm
      , row.names = F, append = F
    )
  
}else{
  # dbh data
  trees_dbh_ans <- readr::read_csv( dbh_fnm_temp, progress = F, show_col_types = F)
}
```

```{r, include=F, eval=TRUE}
processing_data_temp <- readr::read_csv(c2t_tracking_fnm, progress = F, show_col_types = F)
```

```{r, include=F, eval=F}
# model trees
regional_dbh_height_model_training_data_temp <- file.path(c2t_process_dir, "regional_dbh_height_model_training_data.csv") %>% 
  readr::read_csv(show_col_types = F, progress = F) 

regional_dbh_height_model_training_data_temp %>% 
  dplyr::glimpse()

regional_dbh_height_model_training_data_temp %>% 
  dplyr::count(species_symbol) %>% 
  dplyr::arrange(desc(n))

regional_dbh_height_model_training_data_temp %>% 
  ggplot2::ggplot(mapping = ggplot2::aes(x = dbh_cm)) +
  ggplot2::geom_density()

regional_dbh_height_model_training_data_temp %>% 
  ggplot2::ggplot(mapping = ggplot2::aes(x = tree_height_m, y = dbh_cm)) +
  ggplot2::geom_point()

regional_dbh_height_model_training_data_temp %>% 
  ggplot2::ggplot(mapping = ggplot2::aes(x = tree_height_m, y = dbh_cm, size = tree_weight)) +
  ggplot2::geom_point()

regional_dbh_height_model_training_data_temp %>% 
  ggplot2::ggplot(mapping = ggplot2::aes(x = tree_height_m, y = dbh_cm, size = tree_weight, color = species_symbol)) +
  ggplot2::geom_point(key_glyph = ggplot2::draw_key_rect)

regional_dbh_height_model_training_data_temp %>% 
  ggplot2::ggplot(mapping = ggplot2::aes(x = tree_height_m, y = dbh_cm, color = species_symbol)) +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(facets = dplyr::vars(species_symbol)) +
  ggplot2::theme(legend.position = "none")

regional_dbh_height_model_training_data_temp %>% 
  ggplot2::ggplot(mapping = ggplot2::aes(x = tree_height_m, y = dbh_cm, color = species_symbol, size = tree_weight)) +
  ggplot2::geom_point() +
  ggplot2::facet_wrap(facets = dplyr::vars(species_symbol)) +
  ggplot2::theme(legend.position = "none")
  
```

Estimating DBH for our tree list of **`r scales::comma(nrow(trees_dbh_ans), accuracy = .01)`** trees took **`r scales::comma(processing_data_temp$timer_trees_dbh_mins, accuracy = .1)`** minutes

let's check the relationship between height and DBH as estimated by the regional allometric relationship

```{r}
trees_dbh_ans %>% 
  dplyr::slice_sample(n=7777) %>% 
  ggplot2::ggplot(mapping = ggplot2::aes(x = tree_height_m, y = dbh_cm)) + 
  ggplot2::geom_point(color = "navy", alpha = 0.6) +
  ggplot2::labs(x = "tree ht. (m)", y = "tree DBH (cm)") +
  ggplot2::scale_x_continuous(limits = c(0,NA)) +
  ggplot2::scale_y_continuous(limits = c(0,NA)) +
  ggplot2::theme_light()
```

Let's look at the distribution of tree diameter in our study area

```{r}
trees_dbh_ans %>%
  ggplot2::ggplot(mapping = ggplot2::aes(x = dbh_cm)) +
  ggplot2::geom_density(fill = "brown", color = "brown", alpha = 0.2) +
  ggplot2::scale_x_continuous(breaks = scales::breaks_extended(11)) +
  ggplot2::labs(x = "tree DBH (cm)", y = "") +
  ggplot2::theme_light() +
  ggplot2::theme(axis.text.y = ggplot2::element_blank(), axis.ticks.y = ggplot2::element_blank())
```

...that's a lot of small trees

let's look at the summary statistics

```{r}
trees_dbh_ans$dbh_cm %>% summary()
```

`cloud2trees::trees_dbh()` saved the actual model estimated using the Bayesian modelling package `brms` which we can load and review

```{r}
dbh_mod_temp <- readRDS( file.path(c2t_process_dir, "regional_dbh_height_model.rds") )
# what is this?
dbh_mod_temp %>% class()
```

we can draw fit curves with probability bands using the `tidybayes` package

```{r}
library(tidybayes)
# define our height range to predict over
dplyr::tibble(tree_height_m = seq(from = 0, to = 50, by = 1)) %>% 
  tidybayes::add_epred_draws(dbh_mod_temp, ndraws = 2000) %>% 
  ggplot2::ggplot(ggplot2::aes(x = tree_height_m)) +
    tidybayes::stat_lineribbon(
      ggplot2::aes(y = .epred, color = "estimate")
      , .width = c(0.5,0.95)
      , lwd = 0.6
    ) +
    ggplot2::scale_fill_brewer(palette = "Oranges") +
    ggplot2::scale_color_manual(values = c("gray33")) +
    ggplot2::labs(x = "tree ht. (m)", y = "est. tree DBH (cm)", color = "") +
    ggplot2::scale_x_continuous(limits = c(0,NA), breaks = scales::extended_breaks(n=11)) +
    ggplot2::scale_y_continuous(limits = c(0,NA), breaks = scales::extended_breaks(n=11)) +
    ggplot2::theme_light()
```

The probability bands are there in shades of orange but they are so tight to the median estimate that it's impossible to see them. The model confidence bands are so narrow because the model was trained with lots of FIA measured trees over the broad study area

we can check how many FIA measured trees were used to train our model because `cloud2trees::trees_dbh()` also writes the training data to the disk (that's neat, but  we don't always need to see how the sausage is made)

```{r}
readr::read_csv(
    "../data/point_cloud_processing_delivery/regional_dbh_height_model_training_data.csv"
    , progress = F
    , show_col_types = F
  ) %>% 
  dplyr::summarise(training_trees = sum(tree_weight)) %>% 
  dplyr::pull(training_trees) %>% 
  scales::comma(accuracy = 1)
```

that's how many FIA measured trees were used to train our model

## HMD Modeling: `trees_hmd()`

The `trees_hmd()` function uses the tree crown polygons we [delineated from the point cloud](#trees) with the columns `treeID` and `tree_height_m` to attempt to extract height to maximum crown diameter (HMD) directly from the height normalized point cloud by finding the height of the non-ground point farthest from the tree center (i.e. tree top). HMD refers to the vertical height at which a tree's crown has its widest horizontal spread. It describes a characteristic of the overall crown shape and structure.

We have `r scales::comma(nrow(raster2trees_ans), suffix = " M", scale = 1e-6, accuracy = .01)` trees but we'll attempt to extract HMD for the full tree list (100% census) and model the trees for which this process cannot extract a value based on the data we successfully extracted from the point cloud. This is a memory-intensive process, so we'll clear all objects from our R session and read them back in later after processing.

```{r, message=FALSE, warning=FALSE}
# clean session
remove(list = base::setdiff(ls(), c("processing_data","dbh_fnm")))
gc()
```

```{r}
# where should we save the file?
hmd_fnm <- "../data/point_cloud_processing_delivery/hmd_data.csv"
# if we don't already have the data, run it
if(!file.exists(hmd_fnm)){
  # sample proportion
  sample_prop_temp <- 1
  # time it
  st_temp <- Sys.time()
  # run it
  trees_hmd_ans <- cloud2trees::trees_hmd(
    trees_poly = "../data/point_cloud_processing_delivery"
    , norm_las = "../data/point_cloud_processing_delivery/norm_las/"
    , tree_sample_prop = sample_prop_temp
    , force_same_crs = T
    , estimate_missing_hmd = T
  )
  # timer
  mins_temp <- difftime(Sys.time(),st_temp,units = "mins") %>% as.numeric()
  processing_data$timer_trees_hmd_mins <- mins_temp
  processing_data$sttng_hmd_tree_sample_n <- NA
  processing_data$sttng_hmd_tree_sample_prop <- sample_prop_temp
  # save hmd
  trees_hmd_ans %>% sf::st_drop_geometry() %>% 
    write.csv(file = hmd_fnm, row.names = F, append = F)
  # save tracking
  processing_data %>% 
    write.csv(
      file = "../data/point_cloud_processing_delivery/processed_tracking_data.csv"
      , row.names = F, append = F
    )
}else{
  # hmd data
  trees_hmd_ans <- readr::read_csv(hmd_fnm, progress = F, show_col_types = F)
}
```

HMD extraction took a total of **`r scales::comma(processing_data$timer_trees_hmd_mins, accuracy = 0.1)`** minutes at processing rate of **`r scales::comma((processing_data$timer_trees_hmd_mins/(nrow(trees_hmd_ans)/1000))*60, accuracy = 0.01)`** seconds per 1,000 trees

We attempted to extract HMD from `r scales::percent(processing_data$sttng_hmd_tree_sample_prop)` of our tree list, let's see our success rate

```{r}
trees_hmd_ans %>% 
  dplyr::count(is_training_hmd) %>% 
  dplyr::mutate(pct = n/sum(n))
```

all of the records marked as "training data" had HMD successfully extracted from the point cloud and were used to estimate a height-HMD allometry relationship that is spatially informed using the relative tree location

let's look at the training versus the modeled HMD versus height

```{r}
trees_hmd_ans %>% 
  dplyr::slice_sample(n = 11111) %>% 
  dplyr::arrange(desc(is_training_hmd)) %>%
  ggplot2::ggplot(mapping = ggplot2::aes(x = tree_height_m, y = max_crown_diam_height_m, color=is_training_hmd)) + 
  ggplot2::geom_point() +
  ggplot2::labs(x = "tree ht. (m)", y = "tree HMD (m)") +
  ggplot2::scale_y_continuous(breaks = scales::extended_breaks(n=12)) +
  ggplot2::scale_x_continuous(breaks = scales::extended_breaks(n=14)) +
  ggplot2::scale_color_viridis_d(option = "turbo", begin = 0.2, alpha = 0.7, name = "is HMD\nfrom cloud?") +
  ggplot2::theme_light()
```

Let's look at the distribution of HMD in our study area

```{r}
trees_hmd_ans %>%
  ggplot2::ggplot(mapping = ggplot2::aes(x = max_crown_diam_height_m)) +
  ggplot2::geom_density(fill = "coral", color = "coral", alpha = 0.2) +
  ggplot2::scale_x_continuous(breaks = scales::breaks_extended(11)) +
  ggplot2::labs(x = "tree HMD (m)", y = "") +
  ggplot2::theme_light() +
  ggplot2::theme(axis.text.y = ggplot2::element_blank(), axis.ticks.y = ggplot2::element_blank())
```

and look at the summary statistics of HMD

```{r}
trees_hmd_ans$max_crown_diam_height_m %>% summary()
```


clean our session

```{r, message=FALSE, warning=FALSE}
# clean session
remove(list = base::setdiff(ls(), c("processing_data","dbh_fnm","hmd_fnm","cbh_fnm")))
gc()
```

## Forest Type: `trees_type()`{#trees_type}

We'll now use `trees_type()` to attach species information using USDA Forest Inventory and Analysis (FIA) codes. FIA Forest Type Group Code is attached to each tree in the tree list based on the spatial overlap with the [Forest Type Groups of the Continental United States](https://www.arcgis.com/home/item.html?id=10760c83b9e44923bd3c18efdaa7319d) data (Wilson 2023).

We now need to read back in our full spatial data frame of points to use as the input tree list, let's just load the tree points

```{r}
# get the data from already run
treetops_sf <-
  list.files(
    "../data/point_cloud_processing_delivery"
    , pattern = "final_detected_tree_tops.*\\.gpkg$"
    , full.names = T
  ) %>% 
  normalizePath() %>% 
  purrr::map(\(x)
    sf::st_read(dsn = x, quiet = T)
  ) %>% 
  dplyr::bind_rows()
```

let's get the FIA forest type group for our list

```{r}
# where should we save the file?
type_fnm <- "../data/point_cloud_processing_delivery/type_data.csv"
type_rast_fnm <- "../data/point_cloud_processing_delivery/type_rast.tif"
# if we don't already have the data, run it
if(!file.exists(type_fnm)){
  # time it
  st_temp <- Sys.time()
  # run it
  trees_type_ans <- cloud2trees::trees_type(
    tree_list = treetops_sf
    , study_boundary = 
      sf::st_read("../data/point_cloud_processing_delivery/raw_las_ctg_info.gpkg") %>% 
        sf::st_union()
  )
  # timer
  mins_temp <- difftime(Sys.time(),st_temp,units = "mins") %>% as.numeric()
  processing_data$timer_trees_type_mins <- mins_temp
  # save type
  trees_type_ans$tree_list %>% 
    sf::st_drop_geometry() %>% 
    write.csv(file = type_fnm, row.names = F, append = F)
  # save raster
  trees_type_ans$foresttype_rast %>% terra::writeRaster(type_rast_fnm, overwrite=T)
  # save tracking
  processing_data %>% 
    write.csv(
      file = "../data/point_cloud_processing_delivery/processed_tracking_data.csv"
      , row.names = F, append = F
    )
}else{
  trees_type_ans <- list()
  # type data
  trees_type_ans$tree_list <- readr::read_csv(type_fnm, progress = F, show_col_types = F)
  # raster
  trees_type_ans$foresttype_rast <- terra::rast(type_rast_fnm)
}
```

Let's look at the FIA Forest Type Group data we extracted for the tree list.

```{r}
trees_type_ans$tree_list %>%
  sf::st_drop_geometry() %>% 
  dplyr::count(forest_type_group_code, forest_type_group) %>% 
  dplyr::arrange(desc(n)) %>% 
  dplyr::mutate(pct = n/sum(n)) %>% 
  kableExtra::kbl(caption = "Count of trees by FIA Forest Type Group", digits = 2) %>% 
  kableExtra::kable_styling()
```

Let's attach FIA Forest Types Group name to the raster (`foresttype_rast`) of the area we searched and plot it

```{r}
# load in the forest type data
ext_data_temp <- cloud2trees::find_ext_data()
foresttype_lookup <- file.path(ext_data_temp$foresttype_dir, "foresttype_lookup.csv") %>% 
  readr::read_csv(progress = F, show_col_types = F) %>% 
  dplyr::distinct(forest_type_group_code, forest_type_group, hardwood_softwood)
# what?
foresttype_lookup %>% dplyr::glimpse()
```

plot the FIA Forest Types Group raster of our study area

```{r, message=FALSE, results=F}
# study area
aoi_temp <- sf::st_read("../data/point_cloud_processing_delivery/raw_las_ctg_info.gpkg") %>% 
  sf::st_transform(terra::crs(trees_type_ans$foresttype_rast))
# plot raster
r_plt <-
  trees_type_ans$foresttype_rast %>%
    terra::crop(aoi_temp %>% sf::st_buffer(100) %>% terra::vect()) %>% 
    terra::as.data.frame(xy=T) %>% 
    dplyr::rename(forest_type_group_code = 3) %>% 
    dplyr::left_join(foresttype_lookup, by = "forest_type_group_code") %>% 
    ggplot2::ggplot() + 
    ggplot2::geom_tile(mapping = ggplot2::aes(x=x, y=y, fill = forest_type_group)) +
    ggplot2::labs(fill = "FIA forest\ntype group") +
    harrypotter::scale_fill_hp_d("lunalovegood", direction=-1) +
    ggplot2::theme_void() +
    ggplot2::theme(legend.position = "top") +
    ggplot2::guides(fill = ggplot2::guide_legend(nrow = 2, byrow = T))
# add our study boundary
r_plt +
  ggplot2::geom_sf(data = aoi_temp, color = "white", fill = NA)
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
remove(foresttype_lookup, r_plt, trees_type_ans)
gc()
```

## Combine data

before our last tree component calculation, we'll bring all of our data together because the last component relies on this data

```{r}
# read all of our data back in
trees_dbh_temp <-
  readr::read_csv(
    dbh_fnm
    , col_select = c(
      treeID, tidyselect::contains("dbh")
      , tidyselect::starts_with("basal_area")
      , tidyselect::starts_with("radius")
    )
    , show_col_types = F
    , progress = F
  )
trees_cbh_temp <-
  readr::read_csv(
    cbh_fnm
    , col_select = c(treeID, tree_cbh_m, is_training_cbh)
    , show_col_types = F
    , progress = F
  )
trees_hmd_temp <-
  readr::read_csv(
    hmd_fnm
    , col_select = c(treeID, max_crown_diam_height_m, is_training_hmd)
    , show_col_types = F
    , progress = F
  )
trees_type_temp <-
  readr::read_csv(
    type_fnm
    , col_select = c(treeID, tidyselect::starts_with("forest_type"), hardwood_softwood)
    , show_col_types = F
    , progress = F
  )
# function re-cast treeID if needed
recast_id_fn <- function(df, cl) {
  if(
    !inherits(
      df$treeID
      , cl
    )
  ){
    if(cl=="character"){
      df$treeID <- format(df$treeID, scientific = F, trim = T) %>% 
        as.character() %>% 
        stringr::str_squish()
    }else if(cl=="numeric"){
      df$treeID <- as.numeric(df$treeID)
    }
  }
  return(df)
}
# apply
trees_dbh_temp <- trees_dbh_temp %>% 
  recast_id_fn(cl = class(treetops_sf$treeID))
trees_cbh_temp <- trees_cbh_temp %>% 
  recast_id_fn(cl = class(treetops_sf$treeID))
trees_hmd_temp <- trees_hmd_temp %>% 
  recast_id_fn(cl = class(treetops_sf$treeID))
trees_type_temp <- trees_type_temp %>% 
  recast_id_fn(cl = class(treetops_sf$treeID))
# c("700000","600000","100000","200000","300000","2000000","800000","400000","1000000","900000","500000" )
# trees_type_temp %>% 
#   dplyr::filter(
#     treeID %in% 
#       c("700000","600000","100000","200000","300000","2000000","800000","400000","1000000","900000","500000" )
#   )
# now we'll get a list of the columns in our component data to drop from our main data
cols_to_drop_temp <- c(
    names(trees_dbh_temp), names(trees_cbh_temp)
    , names(trees_hmd_temp), names(trees_type_temp) 
  ) %>% 
  unique() %>% 
  setdiff("treeID")
# remove cols from our primary data
treetops_sf <- treetops_sf %>% 
  dplyr::select( -dplyr::any_of(cols_to_drop_temp))
# join altogether using the magical purrr::reduce
treetops_sf <-
  list(
    treetops_sf, trees_dbh_temp, trees_cbh_temp
    , trees_hmd_temp, trees_type_temp
  ) %>% 
  purrr::reduce(\(x,y) dplyr::left_join(x, y, by = "treeID"))
```

let's glimpse our almost final data

```{r}
treetops_sf %>% dplyr::glimpse()
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
remove(list = ls()[grep("_temp",ls())])
gc()
```

## Crown Biomass: `trees_biomass()`{#trees_biomass}

Lastly, we'll use `trees_biomass()` to estimate tree crown biomass in kilograms. We'll estimate biomass based on: 1) LANDFIRE's [Forest Canopy Bulk Density (CBD) data](https://landfire.gov/fuel/cbd); and 2) based on the [Cruz et al. (2003)](https://scholar.google.com/scholar?cluster=316241498622221569&oi=gsb&hl=en&as_sdt=0,5) equations and the FIA forest type group we got above

```{r, include=FALSE, eval=FALSE}
treetops_sf %>% 
  sf::st_drop_geometry() %>% 
  dplyr::filter(
    treeID %in%
    c("700000","600000","100000","200000","300000","2000000","800000","400000","1000000","900000","500000" )
  ) %>% 
  dplyr::arrange(treeID) %>% 
  View()

treetops_sf %>% 
      dplyr::filter(
        treeID %in%
        c("700000","600000","100000","200000","300000","2000000","800000","400000","1000000","900000","500000" )
      ) %>% 
      dplyr::bind_rows(
        treetops_sf %>% 
          dplyr::filter(
            !treeID %in%
            c("700000","600000","100000","200000","300000","2000000","800000","400000","1000000","900000","500000" )
          ) %>% 
        dplyr::slice_sample(n = 6666)
      ) %>% sf::st_write("c:/users/georg/Downloads/wtf.gpkg")

trees_biomass_ans <- cloud2trees::trees_biomass(
    tree_list = sf::st_read("c:/users/georg/Downloads/wtf.gpkg")
    , method = c("cruz","landfire")
  )
trees_biomass_ans$tree_list %>% 
  sf::st_drop_geometry() %>% 
  dplyr::filter(
    treeID %in%
    as.numeric(c("700000","600000","100000","200000","300000","2000000","800000","400000","1000000","900000","500000" ))
    # is.na(landfire_crown_biomass_kg)
  ) %>%
  dplyr::arrange(landfire_crown_biomass_kg, treeID) %>% 
  View()
```

```{r}
# where should we save the file?
biomass_fnm <- "../data/point_cloud_processing_delivery/biomass_data.csv"
# if we don't already have the data, run it
if(!file.exists(biomass_fnm)){
  # time it
  st_temp <- Sys.time()
  # run it
  trees_biomass_ans <- cloud2trees::trees_biomass(
    tree_list = treetops_sf
    , method = c("cruz","landfire")
    , study_boundary = 
      sf::st_read("../data/point_cloud_processing_delivery/raw_las_ctg_info.gpkg") %>% 
        sf::st_union()
  )
  # timer
  mins_temp <- difftime(Sys.time(),st_temp,units = "mins") %>% as.numeric()
  processing_data$timer_trees_biomass_mins <- mins_temp
  # save biomass
  trees_biomass_ans$tree_list %>% 
    sf::st_drop_geometry() %>% 
    write.csv(file = biomass_fnm, row.names = F, append = F)
  # save raster df
  trees_biomass_ans$stand_cell_data_landfire %>% 
    sf::st_drop_geometry() %>% 
    write.csv(file = "../data/point_cloud_processing_delivery/stand_cell_data_landfire.csv", row.names = F, append = F)
  trees_biomass_ans$stand_cell_data_cruz %>% 
    sf::st_drop_geometry() %>% 
    write.csv(file = "../data/point_cloud_processing_delivery/stand_cell_data_cruz.csv", row.names = F, append = F)
  # save tracking
  processing_data %>% 
    write.csv(
      file = "../data/point_cloud_processing_delivery/processed_tracking_data.csv"
      , row.names = F, append = F
    )
}else{
  trees_biomass_ans <- list()
  # biomass data
  trees_biomass_ans$tree_list <- readr::read_csv(biomass_fnm, progress = F, show_col_types = F)
  # raster
  trees_biomass_ans$stand_cell_data_landfire <- 
    readr::read_csv(file = "../data/point_cloud_processing_delivery/stand_cell_data_landfire.csv", progress = F, show_col_types = F)
  trees_biomass_ans$stand_cell_data_cruz <- 
    readr::read_csv(file = "../data/point_cloud_processing_delivery/stand_cell_data_cruz.csv", progress = F, show_col_types = F)
}
```


Tree crown biomass estimation took a total of **`r scales::comma(processing_data$timer_trees_biomass_mins, accuracy = 0.1)`** minutes at processing rate of **`r scales::comma((processing_data$timer_trees_biomass_mins/round(processing_data$las_area_m2[1]/10000))*60, accuracy = 0.01)`** seconds per hectare

The `trees_biomass()` process constrains tree crown bulk density (CBD) values to 2.0 kilograms per cubic meter by default based on [Mell et al. (2009)](https://doi.org/10.1016/j.combustflame.2009.06.015) who found the dry bulk density of the tree crown was 2.6 kilograms per cubed meter using Douglas-fir trees grown on Christmas tree farms. Let's check the distribution of CBD values estimated in our study area.

```{r}
trees_biomass_ans$tree_list %>% 
  sf::st_drop_geometry() %>% 
  dplyr::select(tidyselect::ends_with("tree_kg_per_m3")) %>% 
  tidyr::pivot_longer(cols = tidyselect::everything()) %>% 
  dplyr::mutate(name = stringr::str_remove_all(name,"_tree_kg_per_m3")) %>% 
  ggplot2::ggplot(ggplot2::aes(x = value, color = name, fill = name)) +
    ggplot2::geom_density() +
    ggplot2::facet_grid(cols = dplyr::vars(name)) +
    ggplot2::scale_fill_viridis_d(option = "turbo", begin = 0.3, end = 0.7, alpha = 0.7, name = "biomass method") +
    ggplot2::scale_color_viridis_d(option = "turbo", begin = 0.3, end = 0.7,name = "biomass method") +
    ggplot2::scale_x_continuous(breaks = scales::breaks_extended(8)) +
    ggplot2::labs(x = "tree kilograms per cubic meter", y = "") +
    ggplot2::theme_light() +
    ggplot2::theme(legend.position = "none")
```

let's look at the summary of the tree CBD values and the resulting crown biomass

```{r}
trees_biomass_ans$tree_list %>% 
  sf::st_drop_geometry() %>% 
  dplyr::select(tidyselect::ends_with("tree_kg_per_m3"), tidyselect::ends_with("crown_biomass_kg")) %>%
  summary()
```

note those NA values for the Cruz et al. (2003) method, these NA values are introduced because this particular methodology is limited in the forest types for which biomass equations exist

check out the break-down by FIA forest type group

```{r}
trees_biomass_ans$tree_list %>% 
  sf::st_drop_geometry() %>%
  dplyr::filter(!is.na(forest_type_group)) %>% 
  dplyr::group_by(forest_type_group) %>% 
  dplyr::summarise(
    n = dplyr::n()
    , dplyr::across(
      cruz_tree_kg_per_m3
      , .fns = list(mean = mean, sd = sd, min = min, max = max)
    )
  ) %>% 
  dplyr::rename_with(~ stringr::str_remove_all(.x,"cruz_tree_kg_per_m3_")) %>% 
  dplyr::arrange(desc(n)) %>% 
  kableExtra::kbl(caption = "Summary of tree CBD (kg per m3) by FIA Forest Type Group", digits = 2) %>% 
  kableExtra::kable_styling()  
```

We can see how the LANDFIRE [Forest Canopy Bulk Density (CBD) data](https://landfire.gov/fuel/cbd) and [Cruz et al. (2003)](https://scholar.google.com/scholar?cluster=316241498622221569&oi=gsb&hl=en&as_sdt=0,5) methodologies compare at estimating tree crown biomass for our study area

we'll make this comparison only for trees that have biomass estimated using the Cruz method as well

```{r, message=FALSE, warning=FALSE}
# set the upper limit scale
ul_temp <- max(
  quantile(trees_biomass_ans$tree_list$cruz_crown_biomass_kg, probs = 0.95, na.rm = T)
  , quantile(trees_biomass_ans$tree_list$landfire_crown_biomass_kg, probs = 0.95, na.rm = T)
)
# plot tree landfire vs. cruz crown biomass estimate
trees_biomass_ans$tree_list %>%
  sf::st_drop_geometry() %>% 
  dplyr::filter(!is.na(cruz_crown_biomass_kg)) %>% 
  dplyr::slice_sample(n=11111) %>% 
  ggplot2::ggplot(
    mapping = ggplot2::aes(
      x = landfire_crown_biomass_kg, y = cruz_crown_biomass_kg
    )
  ) +
  ggplot2::geom_abline(lwd = 1.5) +
  ggplot2::geom_point(ggplot2::aes(color = tree_height_m)) +
  ggplot2::geom_smooth(method = "lm", se=F, color = "tomato", linetype = "dashed") +
  ggplot2::scale_color_viridis_c(option = "mako", direction = -1, alpha = 0.8) +
  ggplot2::scale_x_continuous(limits = c(0, ul_temp)) +
  ggplot2::scale_y_continuous(limits = c(0, ul_temp)) +
  ggplot2::labs(
    x = "LANDFIRE crown biomass (kg)"
    , y = "Cruz crown biomass (kg)"
    , color = "tree ht. (m)"
  ) +
  ggplot2::theme_light()
```

we can summarize the average difference between the two methods for records with both estimates

```{r}
trees_biomass_ans$tree_list %>%
  sf::st_drop_geometry() %>% 
  dplyr::filter(!is.na(cruz_crown_biomass_kg)) %>% 
  dplyr::mutate(
    diff_cruz_lf_kg = cruz_crown_biomass_kg-landfire_crown_biomass_kg
    , pct_diff_cruz_lf_kg = diff_cruz_lf_kg/landfire_crown_biomass_kg
  ) %>% 
  dplyr::summarise(
    dplyr::across(
      c(cruz_crown_biomass_kg,landfire_crown_biomass_kg,diff_cruz_lf_kg,pct_diff_cruz_lf_kg)
      , .fns = list(mean = mean)
      , .names = "{.fn}_{.col}"
    )
  ) %>% 
  dplyr::mutate(
    mean_pct_diff_cruz_lf_kg = scales::percent(mean_pct_diff_cruz_lf_kg, accuracy = 0.1)
    , dplyr::across(
      .cols = -mean_pct_diff_cruz_lf_kg
      , .fns = ~scales::comma(.x,accuracy = 0.01)
    )
  ) %>% 
  tidyr::pivot_longer(tidyselect::everything()) %>% 
  kableExtra::kbl(caption = "Mean difference between LANDFIRE and Cruz estimated tree crown biomass in kilograms", digits = 2) %>% 
  kableExtra::kable_styling()  
```

Finally, let's plot the spatial arrangement of estimated biomass using the raster data returned from `trees_biomass()`

First, for LANDFIRE

```{r}
# aoi
aoi_temp <- sf::st_read("../data/point_cloud_processing_delivery/raw_las_ctg_info.gpkg")
# get the projection for the stand cell data
epsg_code_temp <- trees_biomass_ans$stand_cell_data_landfire$rast_epsg_code[1] %>% as.numeric()
# set the color limit
ul_temp <- max(
  max(trees_biomass_ans$stand_cell_data_landfire$landfire_stand_kg_per_m3, na.rm = T)
  , max(trees_biomass_ans$stand_cell_data_cruz$cruz_stand_kg_per_m3, na.rm = T)
)
# plot the stand cell data with trees overlaid
trees_biomass_ans$stand_cell_data_landfire %>%
  dplyr::filter(trees>0) %>%
  ggplot2::ggplot() +
  ggplot2::geom_tile(ggplot2::aes(x=x,y=y,fill = landfire_stand_kg_per_m3), color = NA) +
  ggplot2::geom_sf(data = aoi_temp %>% sf::st_transform(crs = epsg_code_temp), fill = NA) +
  ggplot2::labs(subtitle = "LANDFIRE stand kg/m3", fill="LANDFIRE\nstand kg/m3") +
  ggplot2::scale_fill_viridis_c(
    limits = c(NA,ul_temp)
    , option = "rocket", direction = -1, na.value = "white"
  ) +
  ggplot2::coord_sf() +
  ggplot2::theme_void()
```

and for Cruz

```{r}
# get the projection for the stand cell data
epsg_code_temp <- trees_biomass_ans$stand_cell_data_cruz$rast_epsg_code[1] %>% as.numeric()
# plot the stand cell data with trees overlaid
trees_biomass_ans$stand_cell_data_cruz %>%
  dplyr::filter(trees>0) %>%
  ggplot2::ggplot() +
  ggplot2::geom_tile(ggplot2::aes(x=x,y=y,fill = cruz_stand_kg_per_m3), color = NA) +
  ggplot2::geom_sf(data = aoi_temp %>% sf::st_transform(crs = epsg_code_temp), fill = NA) +
  ggplot2::labs(subtitle = "Cruz stand kg/m3", fill="Cruz\nstand kg/m3") +
  ggplot2::scale_fill_viridis_c(
    limits = c(NA,ul_temp)
    , option = "rocket", direction = -1, na.value = "white"
  ) +
  ggplot2::theme_void()
```

## Processing Time Summary

Let's summarize how long all of this point cloud processing took and determine which steps were most computationally intensive.

```{r}
# aggregate the total processing time
processing_data <- processing_data %>% 
  dplyr::mutate(
    timer_total_time_mins = timer_cloud2raster_mins + timer_raster2trees_mins +
      timer_trees_dbh_mins + timer_trees_cbh_mins + timer_trees_type_mins +
      timer_trees_hmd_mins + timer_trees_biomass_mins + timer_write_data_mins
    , timer_tree_extraction_mins = timer_cloud2raster_mins + timer_raster2trees_mins
  ) %>% 
  dplyr::mutate(dplyr::across(
     .cols = c(timer_tree_extraction_mins,
      timer_trees_dbh_mins, timer_trees_cbh_mins, timer_trees_type_mins,
      timer_trees_hmd_mins, timer_trees_biomass_mins, timer_write_data_mins)
     , .fns = ~ .x/timer_total_time_mins
     , .names = "{.col}_pct"
  ))
# table it
table_temp <- processing_data %>% 
  dplyr::select(
    c(timer_tree_extraction_mins,
      timer_trees_dbh_mins, timer_trees_cbh_mins, timer_trees_type_mins,
      timer_trees_hmd_mins, timer_trees_biomass_mins, timer_write_data_mins
      , c(tidyselect::ends_with("_pct") & tidyselect::starts_with("timer_"))
    )
  ) %>% 
  tidyr::pivot_longer(dplyr::everything()) %>% 
  dplyr::mutate(
    units = stringr::word(name, -1, sep = "_")
    , section = name %>% 
      stringr::str_remove_all("timer_") %>% 
      stringr::str_remove_all("_mins") %>% 
      stringr::str_remove_all("_pct")
  ) %>% 
  dplyr::select(-name) %>% 
  tidyr::pivot_wider(names_from = units, values_from = value) %>% 
  dplyr::mutate(
    mins_lab = scales::comma(mins,accuracy = 0.1)
    , pct_lab = scales::percent(pct,accuracy = 0.1)
  )
```

table it

```{r}
table_temp %>% 
  dplyr::select(section, tidyselect::ends_with("_lab")) %>% 
  kableExtra::kbl(
    caption = "Point cloud processing section run time"
    , col.names = c(
      "Processing section"
      , "time (minutes)"
      , "% of total time"
      )
  ) %>% 
  kableExtra::kable_styling()
```

plot it

## Data Export

Now that we have our point cloud-extracted tree list with all of the tree component measurements attached, let's save the data for use in our analysis

first we'll attach the biomass metrics to our spatial tree list
```{r}
# new columns added by trees_biomass()
names_temp <- 
  setdiff(
    trees_biomass_ans$tree_list %>% names()
    , treetops_sf %>% 
      dplyr::select(!tidyselect::starts_with("cruz_")) %>%
      dplyr::select(!tidyselect::starts_with("landfire_")) %>% 
      dplyr::select( -dplyr::any_of(c(
        "crown_dia_m","crown_length_m","crown_volume_m3"
      ))) %>% 
      names()
  )
# recast id if needed
trees_biomass_ans$tree_list <-
  trees_biomass_ans$tree_list %>% 
  recast_id_fn(cl = class(treetops_sf$treeID))
# attach to our spatial tree points
treetops_sf <-
  treetops_sf %>% 
  dplyr::select(!tidyselect::starts_with("cruz_")) %>%
  dplyr::select(!tidyselect::starts_with("landfire_")) %>% 
  dplyr::select( -dplyr::any_of(c(
    "crown_dia_m","crown_length_m","crown_volume_m3"
  ))) %>% 
  dplyr::left_join(
    trees_biomass_ans$tree_list %>%
      sf::st_drop_geometry() %>% 
      dplyr::select(dplyr::all_of(c("treeID", names_temp)))
    , by = "treeID"
  )
# what does our final data look like?
treetops_sf %>% dplyr::glimpse()
```

```{r, warning=FALSE, message=FALSE, echo=FALSE, include=FALSE}
# treetops_sf %>% dplyr::filter(is.na(landfire_crown_biomass_kg)) %>% nrow()
remove(list = ls()[grep("_temp",ls())])
remove(trees_biomass_ans)
gc()
```

load in the crown spatial files and attach the new component data

```{r, eval=FALSE}
crowns_sf <-
  list.files(
    "../data/point_cloud_processing_delivery"
    , pattern = "final_detected_crowns.*\\.gpkg$"
    , full.names = T
  ) %>% 
  normalizePath() %>% 
  purrr::map(\(x)
    sf::st_read(
      dsn = x
      , quiet = T
    )
  ) %>% 
  dplyr::bind_rows()
# the trees are the same, the data in the columns are different
identical(nrow(crowns_sf), nrow(treetops_sf))
# attach the new columns
crowns_sf <- crowns_sf %>% 
  dplyr::select(treeID, tree_x, tree_y) %>% 
  dplyr::inner_join(
    treetops_sf %>%
      sf::st_drop_geometry() %>% 
      dplyr::select(-c(tree_x, tree_y))
    , by = "treeID"
  )
```

use the internal function from `cloud2trees` that writes the polygon and point vector data

```{r}
# this is an internal function from cloud2trees
write_raster2trees_ans <- function(raster2trees_ans, dir) {
  ### write the data to the disk
    if(nrow(raster2trees_ans)>250e3){
      # split up the detected crowns
      raster2trees_ans <- raster2trees_ans %>%
        dplyr::arrange(as.numeric(tree_x),as.numeric(tree_y)) %>%
        # groups of 250k
        dplyr::mutate(grp = ceiling(dplyr::row_number()/250e3))

      write_fnl_temp <- raster2trees_ans$grp %>%
        unique() %>%
        purrr::map(function(x){
          # dsn's
          cf <- file.path( dir, paste0("final_detected_crowns_",x,".gpkg") )
          tf <- file.path( dir, paste0("final_detected_tree_tops_",x,".gpkg") )
          ### write the data to the disk
          # crown vector polygons
          sf::st_write(
            raster2trees_ans %>%
              dplyr::filter(grp == x) %>%
              dplyr::select(-c(grp))
            , dsn = cf
            , append = FALSE
            , quiet = TRUE
          )
          # tree top vector points
          sf::st_write(
            # get tree points
            raster2trees_ans %>%
              dplyr::filter(grp == x) %>%
              dplyr::select(-c(grp)) %>%
              sf::st_drop_geometry() %>%
              sf::st_as_sf(coords = c("tree_x", "tree_y"), crs = sf::st_crs(raster2trees_ans))
            , dsn = tf
            , append = FALSE
            , quiet = TRUE
          )
          return(
            dplyr::tibble(
              crowns_file = cf
              , trees_file = tf
            )
          )
        }) %>%
        dplyr::bind_rows()
    }else{
        # dsn's
        cf <- file.path( dir, "final_detected_crowns.gpkg" )
        tf <- file.path( dir, "final_detected_tree_tops.gpkg" )
        # crown vector polygons
        sf::st_write(
          raster2trees_ans
          , dsn = cf
          , append = FALSE
          , quiet = TRUE
        )
        # tree top vector points
        sf::st_write(
          # get tree points
          raster2trees_ans %>%
            sf::st_drop_geometry() %>%
            sf::st_as_sf(coords = c("tree_x", "tree_y"), crs = sf::st_crs(raster2trees_ans))
          , dsn = tf
          , append = FALSE
          , quiet = TRUE
        )
        # df
        write_fnl_temp <- dplyr::tibble(
          crowns_file = cf
          , trees_file = tf
        )
    }
  return(write_fnl_temp)
}
```

write the final data (this will overwrite our original data from `cloud2trees()` but that's ok because the tree list and spatial information is the same)

```{r, eval=FALSE}
write_raster2trees_ans(crowns_sf, dir = "../data/point_cloud_processing_delivery")
```

