[["index.html", "BLM Tres Rios Field Office: Dawson project area UAS data Section 1 Introduction 1.1 Objective", " BLM Tres Rios Field Office: Dawson project area UAS data George Woolsey 10 February, 2026 Section 1 Introduction The Dawson vegetation treatment project area is located near Dolores, Colorado (USA) on land managed by the BLM Southwest District, Tres Rios Field Office (TRFO). On April 29th and 30th, 2025, BLM Remote Sensing staff mapped approximately 2,000 acres of the Dawson site using an Uncrewed Aerial System (UAS). In total 24 flights were conducted to collect ~5,500 stereo-images. The raw imagery was then processed photogrammetrically with Agisoft Metashape software to produce high-resolution geospatial data products including 3D point cloud data and an RGB spectral orthomosaic. 1.1 Objective The objective of this analysis is to process the aerial point cloud data using the cloud2trees framework (Woolsey et al. 2025) for generating individual tree forest inventory data. cloud2trees provides a streamlined, open-source framework for generating broad-area individual tree inventories from aerial point cloud data. The primary outputs are spatial datasets of tree locations and crown polygons attributed with biophysical metrics such as height, crown dimensions, crown base height (CBH), diameter at breast height (DBH), and crown biomass. While height and location are inherently determined through the detection process, the framework augments these inventories with tree-level biophysical information determined via allometric estimates and integrated supplementary data. These high-resolution datasets support a wide range of applications including fire behavior modeling, evaluation of forest management activities, and habitat characterization. "],["processing.html", "Section 2 Point Cloud Processing 2.1 Data Location 2.2 Point Cloud to Raster: cloud2raster() 2.3 Individial Tree Detection Tuning: itd_tuning() 2.4 Tree Extraction: raster2trees() 2.5 CBH Modeling: trees_cbh() 2.6 DBH Modeling: trees_dbh() 2.7 HMD Modeling: trees_hmd() 2.8 Forest Type: trees_type() 2.9 Combine data 2.10 Crown Biomass: trees_biomass() 2.11 Processing Time Summary 2.12 Data Export", " Section 2 Point Cloud Processing In this section we’ll process the raw point cloud data using cloud2trees developed to provide accessible routines for processing point cloud data collected by airborne lidar or generated using UAS imagery and photogrammetry (e.g. structure from motion). The cloud2trees package can be installed by following the directions listed in the README file on GitHub. If one is still experiencing difficulties installing the package, see the example.R file which details how to install the package using a virgin R instance. ## remotes helps us get packages hosted on github install.packages(&quot;remotes&quot;) ## get cloud2trees remotes::install_github(repo = &quot;georgewoolsey/cloud2trees&quot;, upgrade = F) Load the standard libraries we use to do work # bread-and-butter library(tidyverse) # the tidyverse library(viridis) # viridis colors library(harrypotter) # hp colors library(RColorBrewer) # brewer colors library(scales) # work with number and plot scales library(latex2exp) # visualization library(mapview) # interactive html maps library(kableExtra) # tables library(patchwork) # combine plots # spatial analysis library(terra) # raster library(sf) # simple features library(lidR) # lidar data library(cloud2trees) # the cloud2trees 2.1 Data Location Let’s check out the location of the data we got # directory with the downloaded .las|.laz files f &lt;- &quot;d:/BLM_CO_SWDF_DawsonFuelsTreatment/Final/PointCloud/Tiles&quot; # f &lt;- &quot;d:/BLM_CO_SWDF_DawsonFuelsTreatment/Final/PointCloud/Full/&quot; # is there data? list.files(f, pattern = &quot;.*\\\\.(laz|las)$&quot;) %&gt;% length() # what files are in here? list.files(f, pattern = &quot;.*\\\\.(laz|las)$&quot;)[1:3] what information does lidR read from the catalog? ctg_temp &lt;- lidR::readLAScatalog(f) ctg_temp that’s a lot of points…can an ordinary laptop handle it? we’ll find out. We’ll plot our point cloud data tiles real quick ctg_temp@data %&gt;% dplyr::mutate( nm = basename(filename) %&gt;% stringr::str_remove(&quot;\\\\.[^.]+$&quot;) %&gt;% stringr::str_remove(&quot;BLM_CO_SWDF_DawsonFuelsTreatment_PointCloud_&quot;) ) %&gt;% ggplot2::ggplot() + ggplot2::geom_sf(fill=NA, color = &quot;red&quot;) + ggplot2::theme_light() oh no. something weird is going on with the location of these point cloud tiles…perhaps that’s the reason for the “0 points/m2” message from lidR above no worries, cloud2trees has built-in functionality to handle corrupt point cloud data. let’s see if that functionality can help clean this up ctg_temp %&gt;% cloud2trees:::check_las_ctg_empty() %&gt;% purrr::pluck(&quot;data&quot;) %&gt;% dplyr::mutate( nm = basename(filename) %&gt;% stringr::str_remove(&quot;\\\\.[^.]+$&quot;) %&gt;% stringr::str_remove(&quot;BLM_CO_SWDF_DawsonFuelsTreatment_PointCloud_&quot;) ) %&gt;% ggplot2::ggplot() + ggplot2::geom_sf(fill=NA, color = &quot;red&quot;) + ggplot2::geom_sf_label(mapping = ggplot2::aes(label = nm),size=2) + ggplot2::theme_void() that’s better. let’s look at this on a map to orient ourselves ctg_temp %&gt;% cloud2trees:::check_las_ctg_empty() %&gt;% purrr::pluck(&quot;data&quot;) %&gt;% mapview::mapview(popup = F, layer.name = &quot;point cloud tile&quot;) 2.2 Point Cloud to Raster: cloud2raster() Although the cloud2trees::cloud2trees() function combines methods in the cloud2trees package for an all-in-one approach, we’ll instead use the cloud2trees::cloud2raster() function to generate a CHM from the point cloud that we can work with to perform both individual tree detection and slash pile identification (discussed later). We’ll set the options in the function to generate a CHM which represents a DSM with the ground removed and no other filtering. This high resolution (i.e. fine-grain) CHM will serve as the foundation for tree detection and slash pile detection as we can manipulate it to optimize the processing for both methods. # outdir c2t_output_dir &lt;- &quot;../data&quot; c2t_process_dir &lt;- file.path(c2t_output_dir, &quot;point_cloud_processing_delivery&quot;) c2t_tracking_fnm &lt;- file.path(c2t_process_dir, &quot;processed_tracking_data.csv&quot;) ############################################################## # cloud2trees::cloud2raster ############################################################## if( !file.exists( file.path(c2t_process_dir, &quot;chm_0.1m.tif&quot;) ) || !file.exists( file.path(c2t_process_dir, &quot;dtm_0.25m.tif&quot;) ) ){ # time it st_temp &lt;- Sys.time() # run it # cloud2trees cloud2raster_ans &lt;- cloud2trees::cloud2raster( output_dir = c2t_output_dir , input_las_dir = f , accuracy_level = 2 , keep_intrmdt = T , dtm_res_m = 0.25 , chm_res_m = 0.1 , min_height = 0 # effectively generates a DSM based on non-ground points ) # timer mins_temp &lt;- difftime(Sys.time(),st_temp,units = &quot;mins&quot;) %&gt;% as.numeric() # save tracking dplyr::tibble( timer_cloud2raster_mins = mins_temp ) %&gt;% write.csv( file = c2t_tracking_fnm , row.names = F, append = F ) }else{ dtm_temp &lt;- terra::rast( file.path(c2t_process_dir, &quot;dtm_0.25m.tif&quot;) ) chm_temp &lt;- terra::rast( file.path(c2t_process_dir, &quot;chm_0.1m.tif&quot;) ) cloud2raster_ans &lt;- list( &quot;dtm_rast&quot; = dtm_temp , &quot;chm_rast&quot; = chm_temp ) } let’s see what we got from cloud2trees::cloud2raster() cloud2raster_ans %&gt;% names() ## [1] &quot;dtm_rast&quot; &quot;chm_rast&quot; there’s a DTM # plot to check out the fine-resolution DTM raster cloud2raster_ans$dtm_rast %&gt;% terra::plot(col = harrypotter::hp(n=100, option = &quot;mischief&quot;), main = &quot;DTM (m)&quot;) there’s a CHM # plot to check out the fine-resolution CHM raster cloud2raster_ans$chm_rast %&gt;% terra::plot(col = viridis::plasma(n=100), main = &quot;CHM (m)&quot;) let’s see some details about the CHM # what chm? cloud2raster_ans$chm_rast ## class : SpatRaster ## size : 27426, 42203, 1 (nrow, ncol, nlyr) ## resolution : 0.1, 0.1 (x, y) ## extent : 706698.8, 710919.1, 4191874, 4194616 (xmin, xmax, ymin, ymax) ## coord. ref. : NAD83(2011) / UTM zone 12N (EPSG:6341) ## source : chm_0.1m.tif ## name : focal_mean ## min value : 0.00 ## max value : 22.59 # what data? cloud2raster_ans$chm_rast %&gt;% terra::summary() ## focal_mean ## Min. : 0.02 ## 1st Qu.: 1.94 ## Median : 3.36 ## Mean : 3.30 ## 3rd Qu.: 4.55 ## Max. :20.31 ## NA&#39;s :78839 for tree detection, we’ll aggregate the CHM to a lower resolution (i.e. coarser) to smooth out some of the fine detail that can increase the noise in the tree detection processing. This aggregation process also will speed up the processing and reduce the chances of computational memory issues. ################################################################## # aggregate to make raster more coarse for tree detection ################################################################## # first, we&#39;ll borrow from the `cloud2trees` codebase to get a function to change the resolution of a raster exactly ###___________________________________________### # adjust the resolution of a raster to be in exactly the target resolution ###___________________________________________### if( !file.exists( file.path(c2t_process_dir, &quot;chm_0.25m.tif&quot;) ) ){ agg_chm_rast &lt;- cloud2trees:::adjust_raster_resolution( cloud2raster_ans$chm_rast , target_resolution = 0.25 , fun = max , resample_method = &quot;max&quot; , ofile = file.path(c2t_process_dir, &quot;chm_0.25m.tif&quot;) ) }else{ agg_chm_rast &lt;- terra::rast( file.path(c2t_process_dir, &quot;chm_0.25m.tif&quot;) ) } # what chm? agg_chm_rast ## class : SpatRaster ## size : 10970, 16882, 1 (nrow, ncol, nlyr) ## resolution : 0.25, 0.25 (x, y) ## extent : 706698.8, 710919.3, 4191874, 4194616 (xmin, xmax, ymin, ymax) ## coord. ref. : NAD83(2011) / UTM zone 12N (EPSG:6341) ## source : chm_0.25m.tif ## name : focal_mean ## min value : 0.00 ## max value : 22.59 # what data? agg_chm_rast %&gt;% terra::summary() ## focal_mean ## Min. : 0.02 ## 1st Qu.: 1.91 ## Median : 3.43 ## Mean : 3.37 ## 3rd Qu.: 4.67 ## Max. :20.45 ## NA&#39;s :72757 2.3 Individial Tree Detection Tuning: itd_tuning() The cloud2trees package performs individual tree detection using lidR::locate_trees() with the lidR::lmf() algorithm. The local maximum filter algorithm allows for a constant window size or a variable window size defined by a function. See the lidR package book section by point cloud processing expert Jean-Romain Roussel for excellent detail on ITD and defining window size. The itd_tuning() function is used to visually assess tree crown delineation results from different window size functions used for the detection of individual trees. itd_tuning() allows users to test different window size functions on a sample of data to determine which function is most suitable for the area being analyzed. The preferred function can then be used in the ws parameter in raster2trees() and cloud2trees(). Let’s run itd_tuning() on our CHM data starting with default window size functions ###___________________________________________### # itd_tuning ###___________________________________________### # run it set.seed(99) itd_tuning_ans &lt;- cloud2trees::itd_tuning( input_chm_rast = agg_chm_rast , min_height = 1.37 , n_samples = 2 ) # huh? itd_tuning_ans %&gt;% names() ## [1] &quot;plot_samples&quot; &quot;ws_fn_list&quot; &quot;plot_sample_summary&quot; ## [4] &quot;crowns&quot; plot the detected trees on the CHM itd_tuning_ans$plot_samples ggplot2::ggsave( filename = file.path(c2t_process_dir, &quot;itd_tuning_plot_samples.jpg&quot;) , plot = itd_tuning_ans$plot_samples , height = 7, width = 7 , dpi = &quot;print&quot; ) plot the summary of the detected trees itd_tuning_ans$plot_sample_summary ggplot2::ggsave( filename = file.path(c2t_process_dir, &quot;itd_tuning_plot_sample_summary.jpg&quot;) , plot = itd_tuning_ans$plot_sample_summary , height = 7, width = 9.5 , dpi = &quot;print&quot; ) the exp_fn results in too few trees with crown diameters generally similar to the total tree height which is not expected check the ws_fn_list return which includes the different window size functions tested # what ws_fn_list itd_tuning_ans$ws_fn_list %&gt;% str() ## List of 3 ## $ lin_fn:function (x) ## $ exp_fn:function (x) ## $ log_fn:function (x) let’s look at the function definition for the linear function (lin_fn) # the linear function itd_tuning_ans$ws_fn_list$lin_fn ## function (x) ## { ## y &lt;- dplyr::case_when(is.na(x) ~ 0.001, x &lt; 0 ~ 0.001, x &lt; ## 2 ~ 1, x &gt; 30 ~ 5, TRUE ~ 0.75 + (x * 0.14)) ## return(y) ## } ## &lt;bytecode: 0x000001c860775b90&gt; ## &lt;environment: 0x000001c860773250&gt; let’s plot all of the functions we tested with our call to itd_tuning() using the defaults # shape of the ws functions plt_ws_fn &lt;- ggplot2::ggplot() + ggplot2::geom_function(mapping=ggplot2::aes(color = &quot;lin_fn&quot;),fun=itd_tuning_ans$ws_fn_list$lin_fn, lwd=1.2) + ggplot2::geom_function(mapping=ggplot2::aes(color = &quot;log_fn&quot;),fun=itd_tuning_ans$ws_fn_list$log_fn, lwd=1.2) + ggplot2::geom_function(mapping=ggplot2::aes(color = &quot;exp_fn&quot;),fun=itd_tuning_ans$ws_fn_list$exp_fn, lwd=1.2) + ggplot2::xlim(-5,35) + ggplot2::scale_color_manual( values = c(viridis::viridis(3), &quot;gray&quot;) ) + ggplot2::labs(x = &quot;heights&quot;, y = &quot;ws&quot;, color = &quot;ws function&quot;) + ggplot2::theme_light() plt_ws_fn Let’s define our own custom linear function that slightly decreases the window size for the shortest trees but increases the window for taller trees compared to the default linear function. my_lin_fn &lt;- function (x) { y &lt;- dplyr::case_when( is.na(x) ~ 0.001 , x &lt; 0 ~ 0.001 , x &gt; (5.3-0.51)/0.21 ~ 5.3 , TRUE ~ 0.51 + (x * 0.21) ) return(y) } add to the plot # plt plt_ws_fn + ggplot2::geom_function( fun = my_lin_fn , mapping = ggplot2::aes(color = &quot;my_lin_fn&quot;) , lwd = 2 ) We’ll run another sample test using itd_tuning()with our new function itd_tuning_ans2 &lt;- cloud2trees::itd_tuning( input_chm_rast = agg_chm_rast , min_height = 1.37 , ws_fn_list = list( lin_fn = itd_tuning_ans$ws_fn_list$lin_fn , log_fn = itd_tuning_ans$ws_fn_list$log_fn , my_lin_fn = my_lin_fn ) ) plot the detected trees on the CHM itd_tuning_ans2$plot_samples ggplot2::ggsave( filename = file.path(c2t_process_dir, &quot;itd_tuning_plot_samples2.jpg&quot;) , plot = itd_tuning_ans2$plot_samples , height = 7, width = 7 , dpi = &quot;print&quot; ) plot the summary of the detected trees itd_tuning_ans2$plot_sample_summary ggplot2::ggsave( filename = file.path(c2t_process_dir, &quot;itd_tuning_plot_sample_summary2.jpg&quot;) , plot = itd_tuning_ans2$plot_sample_summary , height = 7, width = 9.5 , dpi = &quot;print&quot; ) notice, there is also a tree crown data frame in the return # what? itd_tuning_ans2$crowns %&gt;% dplyr::glimpse() ## Rows: 882 ## Columns: 9 ## $ sample_number &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,… ## $ ws_fn &lt;chr&gt; &quot;lin_fn&quot;, &quot;lin_fn&quot;, &quot;lin_fn&quot;, &quot;lin_fn&quot;, &quot;lin_fn&quot;, &quot;li… ## $ treeID &lt;chr&gt; &quot;1_708793.4_4193260.5&quot;, &quot;2_708798.7_4193259.5&quot;, &quot;3_70… ## $ tree_height_m &lt;dbl&gt; 4.02, 4.83, 2.86, 3.54, 2.83, 3.98, 3.31, 1.48, 3.74,… ## $ tree_x &lt;dbl&gt; 708793.4, 708798.7, 708810.7, 708813.2, 708811.4, 708… ## $ tree_y &lt;dbl&gt; 4193260, 4193259, 4193259, 4193259, 4193258, 4193258,… ## $ crown_area_m2 &lt;dbl&gt; 0.8125, 5.1875, 1.1250, 2.3125, 3.6250, 1.5000, 2.312… ## $ geometry &lt;GEOMETRY [m]&gt; POLYGON ((708793.3 4193261,..., MULTIPOLYGON… ## $ crown_diameter_m &lt;dbl&gt; 2.0155644, 3.1324910, 1.5811388, 2.2360680, 2.9154759… # count trees by sample itd_tuning_ans2$crowns %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(sample_number, ws_fn) ## # A tibble: 9 × 3 ## sample_number ws_fn n ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 1 lin_fn 79 ## 2 1 log_fn 99 ## 3 1 my_lin_fn 84 ## 4 2 lin_fn 75 ## 5 2 log_fn 143 ## 6 2 my_lin_fn 89 ## 7 3 lin_fn 90 ## 8 3 log_fn 127 ## 9 3 my_lin_fn 96 with the crowns data we can explore alternative visualizations including overlaying the detected trees on the RGB data if available read RGB #### read RGB data keep only RGB rgb_rast_fnm &lt;- &quot;d:/BLM_CO_SWDF_DawsonFuelsTreatment/Final/Ortho/BLM_CO_SWDF_DawsonFuelsTreatment_Ortho_202504.tif&quot; pj_rgb_rast &lt;- terra::rast(rgb_rast_fnm) %&gt;% terra::subset(c(1,2,3)) plot it # make a function to plot these detected crowns with rgb data plt_rgb_rast_itd_crowns &lt;- function(sample_nmbr = 1, rgb_rast, itd_crowns, plt_lwd = 0.7) { # crop crp_rgb_rast_temp &lt;- rgb_rast %&gt;% terra::crop( itd_crowns %&gt;% dplyr::ungroup() %&gt;% dplyr::filter(sample_number == sample_nmbr) %&gt;% sf::st_union() %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% sf::st_buffer(0.2) %&gt;% sf::st_transform(terra::crs(rgb_rast)) %&gt;% terra::vect() ) # convert raster to a data frame and create hex colors # ?grDevices::rgb rgb_df_temp &lt;- crp_rgb_rast_temp %&gt;% terra::as.data.frame(xy = TRUE) %&gt;% dplyr::rename( red = 3, green = 4, blue = 5 ) %&gt;% dplyr::mutate( hex_col = grDevices::rgb( red , green , blue , maxColorValue = 255 ) ) # dplyr::glimpse() # plt plt &lt;- ggplot2::ggplot() + # add rgb base map ggplot2::geom_raster(data = rgb_df_temp, mapping = ggplot2::aes(x = x, y = y, fill = hex_col)) + # use identity scale so the hex codes are used directly ggplot2::scale_fill_identity() + # overlay polygons # ggplot2::geom_sf(data = polys, fill = NA, color = &quot;red&quot;, linewidth = 0.5) + ggplot2::geom_sf( data = itd_crowns %&gt;% dplyr::filter(sample_number==sample_nmbr) %&gt;% cloud2trees::simplify_multipolygon_crowns() %&gt;% sf::st_make_valid() %&gt;% dplyr::filter(sf::st_is_valid(.)) %&gt;% sf::st_transform(terra::crs(crp_rgb_rast_temp)) , mapping = ggplot2::aes(color = ws_fn) , fill = NA , lwd = plt_lwd , inherit.aes = F ) + ggplot2::facet_grid(cols = dplyr::vars(ws_fn)) + ggplot2::scale_color_viridis_d(name = &quot;&quot;) + ggplot2::coord_sf(expand = F) + ggplot2::theme_void() + ggplot2::theme( legend.position = &quot;none&quot; , strip.text = ggplot2::element_text(face = &quot;bold&quot;, color = &quot;black&quot;, margin = ggplot2::margin(t = 4, b = 4)) , strip.background = ggplot2::element_rect(fill = &quot;gray88&quot;, color = &quot;gray88&quot;) , panel.spacing = ggplot2::unit(1,&quot;lines&quot;) ) return(plt) } plot the trees detected in sample one on the RGB plt_rgb_rast_itd_crowns(sample_nmbr = 1, rgb_rast = pj_rgb_rast, itd_crowns = itd_tuning_ans2$crowns) this is only moderately helpful as the tree density in tree clumps is difficult to infer from the 2D aerial imagery alone. let’s move forward with the default linear function in the raster2trees() function my_ws_fn &lt;- cloud2trees::itd_ws_functions()[[&quot;lin_fn&quot;]] 2.4 Tree Extraction: raster2trees() Now, perform individual tree detection using raster2trees() on the aggregated CHM ############################################################## # cloud2trees::raster2trees ############################################################## search_temp &lt;- cloud2trees:::search_dir_final_detected(dir = c2t_process_dir) if( is.null(search_temp$crowns_flist) || is.null(search_temp$ttops_flist) ){ # time it st_temp &lt;- Sys.time() # run it # cloud2trees raster2trees_ans &lt;- cloud2trees::raster2trees( chm_rast = agg_chm_rast , outfolder = c2t_process_dir , ws = my_ws_fn , min_height = 1.37 , min_crown_area = 0.5 ) # raster2trees_ans # timer mins_temp &lt;- difftime(Sys.time(),st_temp,units = &quot;mins&quot;) %&gt;% as.numeric() # save tracking readr::read_csv(c2t_tracking_fnm, progress = F, show_col_types = F) %&gt;% dplyr::mutate( timer_raster2trees_mins = mins_temp ) %&gt;% write.csv( file = c2t_tracking_fnm , row.names = F, append = F ) }else{ search_dir_final_detected_ans_temp &lt;- cloud2trees:::search_dir_final_detected(dir = c2t_process_dir) crowns_flist_temp &lt;- search_dir_final_detected_ans_temp$crowns_flist # read it to get the full list of tree polygons raster2trees_ans &lt;- crowns_flist_temp %&gt;% purrr::map(function(x){ sf::st_read( dsn = x , quiet = T ) %&gt;% # throw in hey_xxxxxxxxxx to test it works if we include non-existant columns dplyr::select( -dplyr::any_of(c( &quot;hey_xxxxxxxxxx&quot; , &quot;tree_cbh_m&quot; , &quot;is_training_cbh&quot; ))) }) %&gt;% dplyr::bind_rows() } we should have a spatial tree list with tree height and crown dimensions attached raster2trees_ans %&gt;% dplyr::glimpse() ## Rows: 625,378 ## Columns: 6 ## $ treeID &lt;chr&gt; &quot;270511_706700.2_4193508&quot;, &quot;273702_706701.7_4193500&quot;, &quot;2… ## $ tree_height_m &lt;dbl&gt; 1.88, 4.37, 2.00, 6.13, 3.21, 4.08, 4.67, 5.79, 2.49, 4.… ## $ tree_x &lt;dbl&gt; 706700.2, 706701.7, 706702.2, 706702.4, 706703.2, 706703… ## $ tree_y &lt;dbl&gt; 4193508, 4193500, 4193498, 4193502, 4193468, 4193469, 41… ## $ crown_area_m2 &lt;dbl&gt; 0.5000, 4.6250, 1.1250, 5.7500, 1.5625, 2.8750, 2.3125, … ## $ geom &lt;MULTIPOLYGON [m]&gt; MULTIPOLYGON (((706700.1 41..., MULTIPOLYGO… That’s a lot of trees! Let’s plot some on the RGB imagery for the central part of the data. This time, we’ll use terra plotting to demonstrate aoi_temp &lt;- raster2trees_ans %&gt;% dplyr::slice_sample(prop=0.1) %&gt;% sf::st_point_on_surface() %&gt;% sf::st_union() %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% sf::st_centroid() %&gt;% sf::st_buffer(22, endCapStyle = &quot;SQUARE&quot;) # rgb pj_rgb_rast %&gt;% terra::crop( aoi_temp %&gt;% sf::st_transform(terra::crs(pj_rgb_rast)) %&gt;% terra::vect() ) %&gt;% terra::plotRGB(stretch = &quot;lin&quot;, axes = F) # trees terra::plot( raster2trees_ans %&gt;% dplyr::inner_join( raster2trees_ans %&gt;% sf::st_intersection( aoi_temp %&gt;% sf::st_buffer(-2) ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID) , by = &quot;treeID&quot; ) %&gt;% dplyr::ungroup() %&gt;% cloud2trees::simplify_multipolygon_crowns() %&gt;% sf::st_transform(terra::crs(pj_rgb_rast)) %&gt;% terra::vect() , add = T , border = &quot;brown&quot;, col = NA, lwd = 1.2 ) That looks like we did a decent job extracting trees. Remember we set a minimum tree height of 1.37 m (DBH) and we may want to filter out small trees as the analysis proceeds. Let’s look at the distribution of tree height in our study area. # there are always tree heights raster2trees_ans %&gt;% ggplot2::ggplot(mapping = ggplot2::aes(x = tree_height_m)) + ggplot2::geom_density(fill = &quot;navy&quot;, color = &quot;navy&quot;, alpha = 0.2) + ggplot2::scale_x_continuous(breaks = scales::breaks_extended(11)) + ggplot2::labs(x = &quot;tree ht. (m)&quot;, y = &quot;&quot;) + ggplot2::theme_light() + ggplot2::theme(axis.text.y = ggplot2::element_blank(), axis.ticks.y = ggplot2::element_blank()) let’s look at the summary statistics of tree height raster2trees_ans$tree_height_m %&gt;% summary() ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.370 2.930 4.120 4.147 5.180 22.590 Notice above we tracked the time it took to process the data. let’s see how long those cloud2trees processing steps took to run. Run times are, of course, dependent on computer processing and I am working on a laptop typical of a spatial analyst (especially outside of the US Federal Government) running Windows with an Intel i7-10750H 6-core computer processor unit and 32 gigabytes of random-access memory. # load processing extent raw_las_ctg_info &lt;- file.path(c2t_process_dir,&quot;raw_las_ctg_info.gpkg&quot;) %&gt;% sf::st_read(quiet = T) %&gt;% dplyr::mutate(area_m2 = sf::st_area(.) %&gt;% as.numeric()) # load processed_tracking_data.csv processing_data &lt;- readr::read_csv( file = c2t_tracking_fnm , progress = F , show_col_types = F ) # what? processing_data %&gt;% dplyr::select(timer_cloud2raster_mins, timer_raster2trees_mins) %&gt;% dplyr::glimpse() ## Rows: 1 ## Columns: 2 ## $ timer_cloud2raster_mins &lt;dbl&gt; 327.3623 ## $ timer_raster2trees_mins &lt;dbl&gt; 13.21568 let’s do some math # total tree extraction time trees_mins_temp &lt;- processing_data$timer_cloud2raster_mins[1] + processing_data$timer_raster2trees_mins[1] # ha m2_temp &lt;- raw_las_ctg_info %&gt;% sf::st_drop_geometry() %&gt;% dplyr::summarise( m2 = sum(area_m2) ) %&gt;% dplyr::pull(m2) # pts pts_temp &lt;- raw_las_ctg_info %&gt;% sf::st_drop_geometry() %&gt;% dplyr::summarise( pts = sum(Number.of.point.records) ) %&gt;% dplyr::pull(pts) # secs per ha rate_temp &lt;- (trees_mins_temp*60) / (m2_temp/10000) # point density dens_temp &lt;- pts_temp / m2_temp # save tracking readr::read_csv(c2t_tracking_fnm, progress = F, show_col_types = F) %&gt;% dplyr::mutate( number_of_points = pts_temp , las_area_m2 = m2_temp ) %&gt;% write.csv( file = c2t_tracking_fnm , row.names = F, append = F ) Tree extraction over 887.6 hectares took a total of 340.6 minutes at processing rate of 23.02 seconds per hectare on point cloud data with a point density of 590.8 points per square meter (5,244,072,960 points total). 2.5 CBH Modeling: trees_cbh() The trees_cbh() function uses the tree crown polygons we delineated from the point cloud with the columns treeID and tree_height_m to attempt to extract crown base height (CBH) directly from the height normalized point cloud using the process outlined in Viedma et al. (2024). We’ll attempt to extract CBH for a sample and model the rest based on the data we successfully extracted from the point cloud. cbh_fnm &lt;- file.path(c2t_process_dir, &quot;cbh_data.csv&quot;) # if we don&#39;t already have the data, run it if(!file.exists( cbh_fnm )){ # sample proportion sample_prop_temp &lt;- 0.10 # time it st_temp &lt;- Sys.time() # run it trees_cbh_ans &lt;- cloud2trees::trees_cbh( trees_poly = c2t_process_dir , norm_las = file.path(c2t_output_dir, &quot;point_cloud_processing_temp&quot;, &quot;02_normalize&quot;) , tree_sample_prop = sample_prop_temp , which_cbh = &quot;lowest&quot; , estimate_missing_cbh = TRUE , min_vhp_n = 3 , voxel_grain_size_m = 1 , dist_btwn_bins_m = 1 , min_fuel_layer_ht_m = 0.5 , lad_pct_gap = 25 , lad_pct_base = 25 , num_jump_steps = 1 , min_lad_pct = 10 , frst_layer_min_ht_m = 0.5 , force_same_crs = T ) # timer mins_temp &lt;- difftime(Sys.time(),st_temp,units = &quot;mins&quot;) %&gt;% as.numeric() # save cbh trees_cbh_ans %&gt;% sf::st_drop_geometry() %&gt;% write.csv(file = cbh_fnm, row.names = F, append = F) # save tracking readr::read_csv(c2t_tracking_fnm, progress = F, show_col_types = F) %&gt;% dplyr::mutate( timer_trees_cbh_mins = mins_temp , sttng_cbh_tree_sample_n = as.character(NA) , sttng_cbh_tree_sample_prop = sample_prop_temp ) %&gt;% write.csv( file = c2t_tracking_fnm , row.names = F, append = F ) }else{ # cbh data trees_cbh_ans &lt;- readr::read_csv( cbh_fnm, progress = F, show_col_types = F) } CBH extraction took a total of 319.6 minutes (5.3 hours) We attempted to extract CBH from 10% of our tree list (62,538 trees), let’s see our success rate trees_cbh_ans %&gt;% dplyr::count(is_training_cbh) %&gt;% dplyr::mutate(pct = n/sum(n)) ## # A tibble: 2 × 3 ## is_training_cbh n pct ## &lt;lgl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 FALSE 588400 0.941 ## 2 TRUE 36978 0.0591 That equates to a 59.1% CBH extraction success rate….not a great success ;( all of the records marked as training data had CBH successfully extracted from the point cloud and were used to estimate a height-CBH allometry relationship that is spatially informed using the relative tree location let’s look at the training versus the modeled CBH versus height trees_cbh_ans %&gt;% dplyr::slice_sample(n = 11111) %&gt;% dplyr::arrange(is_training_cbh) %&gt;% ggplot2::ggplot(mapping = ggplot2::aes(x = tree_height_m, y = tree_cbh_m, color=is_training_cbh)) + ggplot2::geom_point() + ggplot2::labs(x = &quot;tree ht. (m)&quot;, y = &quot;tree CBH (m)&quot;) + ggplot2::scale_y_continuous(breaks = scales::extended_breaks(n=12)) + ggplot2::scale_x_continuous(breaks = scales::extended_breaks(n=14)) + ggplot2::scale_color_viridis_d(alpha = 0.7, name = &quot;is CBH\\nfrom cloud?&quot;) + ggplot2::theme_light() Let’s look at the distribution of CBH in our study area trees_cbh_ans %&gt;% ggplot2::ggplot(mapping = ggplot2::aes(x = tree_cbh_m)) + ggplot2::geom_density(fill = &quot;maroon4&quot;, color = &quot;maroon4&quot;, alpha = 0.2) + ggplot2::scale_x_continuous(breaks = scales::breaks_extended(11)) + ggplot2::labs(x = &quot;tree CBH (m)&quot;, y = &quot;&quot;) + ggplot2::theme_light() + ggplot2::theme(axis.text.y = ggplot2::element_blank(), axis.ticks.y = ggplot2::element_blank()) and look at the summary statistics of CBH trees_cbh_ans$tree_cbh_m %&gt;% summary() ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.223 1.729 2.009 2.023 2.261 8.500 we can also look at the spatial distribution of the trees for which CBH was successfully extracted # convert to pts real quick treetops_sf &lt;- raster2trees_ans %&gt;% sf::st_drop_geometry() %&gt;% sf::st_as_sf(coords = c(&quot;tree_x&quot;, &quot;tree_y&quot;), crs = sf::st_crs(raster2trees_ans), remove = F) %&gt;% # add on cbh dplyr::left_join( trees_cbh_ans %&gt;% dplyr::select(treeID, is_training_cbh, tree_cbh_m) , by = &quot;treeID&quot; ) # plot treetops_sf %&gt;% dplyr::slice_sample(n = 11111, by = is_training_cbh) %&gt;% ggplot2::ggplot() + ggplot2::geom_sf(mapping = ggplot2::aes(color = is_training_cbh)) + ggplot2::scale_color_viridis_d(alpha = 0.7, name = &quot;is CBH\\nfrom cloud?&quot;) + ggplot2::theme_void() that is good spatial distribution of the training data 2.6 DBH Modeling: trees_dbh() The trees_dbh() function uses the TreeMap FIA plot data in the area of the tree list to estimate the height-DBH allometry relationship. The height predicting DBH model built from the FIA data is then used to predict DBH based on tree height in the tree list. dbh_fnm &lt;- file.path(c2t_process_dir, &quot;dbh_data.csv&quot;) # if we don&#39;t already have the data, run it if(!file.exists( dbh_fnm )){ # time it st_temp &lt;- Sys.time() # run it trees_dbh_ans &lt;- cloud2trees::trees_dbh( tree_list = treetops_sf , boundary_buffer = 2 , outfolder = c2t_process_dir ) # timer mins_temp &lt;- difftime(Sys.time(),st_temp,units = &quot;mins&quot;) %&gt;% as.numeric() # save dbh trees_dbh_ans %&gt;% sf::st_drop_geometry() %&gt;% write.csv(file = dbh_fnm, row.names = F, append = F) # save tracking readr::read_csv(c2t_tracking_fnm, progress = F, show_col_types = F) %&gt;% dplyr::mutate( timer_trees_dbh_mins = mins_temp ) %&gt;% write.csv( file = c2t_tracking_fnm , row.names = F, append = F ) }else{ # dbh data trees_dbh_ans &lt;- readr::read_csv( dbh_fnm, progress = F, show_col_types = F) } Estimating DBH for our tree list of 625,378 trees took 7.9 minutes let’s check the relationship between height and DBH as estimated by the regional allometric relationship trees_dbh_ans %&gt;% dplyr::slice_sample(n=7777) %&gt;% ggplot2::ggplot(mapping = ggplot2::aes(x = tree_height_m, y = dbh_cm)) + ggplot2::geom_point(color = &quot;navy&quot;, alpha = 0.6) + ggplot2::labs(x = &quot;tree ht. (m)&quot;, y = &quot;tree DBH (cm)&quot;) + ggplot2::scale_x_continuous(limits = c(0,NA)) + ggplot2::scale_y_continuous(limits = c(0,NA)) + ggplot2::theme_light() Let’s look at the distribution of tree diameter in our study area trees_dbh_ans %&gt;% ggplot2::ggplot(mapping = ggplot2::aes(x = dbh_cm)) + ggplot2::geom_density(fill = &quot;brown&quot;, color = &quot;brown&quot;, alpha = 0.2) + ggplot2::scale_x_continuous(breaks = scales::breaks_extended(11)) + ggplot2::labs(x = &quot;tree DBH (cm)&quot;, y = &quot;&quot;) + ggplot2::theme_light() + ggplot2::theme(axis.text.y = ggplot2::element_blank(), axis.ticks.y = ggplot2::element_blank()) let’s look at the summary statistics trees_dbh_ans$dbh_cm %&gt;% summary() ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 4.584 14.756 23.626 22.551 30.043 41.932 cloud2trees::trees_dbh() saved the actual model estimated using the Bayesian modelling package brms which we can load and review dbh_mod_temp &lt;- readRDS( file.path(c2t_process_dir, &quot;regional_dbh_height_model.rds&quot;) ) # what is this? dbh_mod_temp %&gt;% class() ## [1] &quot;brmsfit&quot; # model formula dbh_mod_temp ## Family: lognormal ## Links: mu = identity ## Formula: dbh_cm | weights(tree_weight) ~ asym * (1 - exp(-k * tree_height_m))^p ## asym ~ 1 ## k ~ 1 ## p ~ 1 ## Data: treemap_trees_df (Number of observations: 2386) ## Draws: 4 chains, each with iter = 6000; warmup = 3000; thin = 1; ## total post-warmup draws = 12000 ## ## Regression Coefficients: ## Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS ## asym_Intercept 3.63 0.00 3.62 3.63 1.00 3015 4147 ## k_Intercept 0.54 0.00 0.53 0.54 1.00 2233 2941 ## p_Intercept 1.44 0.01 1.42 1.45 1.00 2275 3064 ## ## Further Distributional Parameters: ## Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS ## sigma 0.44 0.00 0.44 0.44 1.00 5531 5420 ## ## Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS ## and Tail_ESS are effective sample size measures, and Rhat is the potential ## scale reduction factor on split chains (at convergence, Rhat = 1). we can draw fit curves with probability bands using the tidybayes package library(tidybayes) # define our height range to predict over dplyr::tibble(tree_height_m = seq(from = 0, to = 30, by = 1)) %&gt;% tidybayes::add_epred_draws(dbh_mod_temp, ndraws = 2000) %&gt;% ggplot2::ggplot(ggplot2::aes(x = tree_height_m)) + tidybayes::stat_lineribbon( ggplot2::aes(y = .epred, color = &quot;estimate&quot;) , .width = c(0.5,0.95) , lwd = 0.6 ) + ggplot2::scale_fill_brewer(palette = &quot;Oranges&quot;) + ggplot2::scale_color_manual(values = c(&quot;gray33&quot;)) + ggplot2::labs(x = &quot;tree ht. (m)&quot;, y = &quot;est. tree DBH (cm)&quot;, color = &quot;&quot;) + ggplot2::scale_x_continuous(limits = c(0,NA), breaks = scales::extended_breaks(n=11)) + ggplot2::scale_y_continuous(limits = c(0,NA), breaks = scales::extended_breaks(n=11)) + ggplot2::theme_light() The probability bands are there in shades of orange but they are so tight to the median estimate that it’s difficult to see them. The model confidence bands are so narrow because the model was trained with lots of FIA measured trees over the broad study area we can check how many FIA measured trees were used to train our model because cloud2trees::trees_dbh() also writes the training data to the disk (that’s neat, but we don’t always need to see how the sausage is made) readr::read_csv( file.path(c2t_process_dir, &quot;regional_dbh_height_model_training_data.csv&quot;) , progress = F , show_col_types = F ) %&gt;% dplyr::summarise(training_trees = sum(tree_weight)) %&gt;% dplyr::pull(training_trees) %&gt;% scales::comma(accuracy = 1) ## [1] &quot;331,111&quot; that’s how many FIA measured trees were used to train our model 2.7 HMD Modeling: trees_hmd() The trees_hmd() function uses the tree crown polygons we delineated from the point cloud with the columns treeID and tree_height_m to attempt to extract height to maximum crown diameter (HMD) directly from the height normalized point cloud by finding the height of the non-ground point farthest from the tree center (i.e. tree top). HMD refers to the vertical height at which a tree’s crown has its widest horizontal spread. It describes a characteristic of the overall crown shape and structure. hmd_fnm &lt;- file.path(c2t_process_dir, &quot;hmd_data.csv&quot;) # if we don&#39;t already have the data, run it if(!file.exists( hmd_fnm )){ # sample proportion sample_prop_temp &lt;- (1/3) # time it st_temp &lt;- Sys.time() # run it trees_hmd_ans &lt;- cloud2trees::trees_hmd( trees_poly = c2t_process_dir , norm_las = file.path(c2t_output_dir, &quot;point_cloud_processing_temp&quot;, &quot;02_normalize&quot;) , tree_sample_prop = sample_prop_temp , force_same_crs = T , estimate_missing_hmd = T ) # timer mins_temp &lt;- difftime(Sys.time(),st_temp,units = &quot;mins&quot;) %&gt;% as.numeric() # save hmd trees_hmd_ans %&gt;% sf::st_drop_geometry() %&gt;% write.csv(file = hmd_fnm, row.names = F, append = F) # save tracking readr::read_csv(c2t_tracking_fnm, progress = F, show_col_types = F) %&gt;% dplyr::mutate( timer_trees_hmd_mins = mins_temp , sttng_hmd_tree_sample_n = as.character(NA) , sttng_hmd_tree_sample_prop = sample_prop_temp ) %&gt;% write.csv( file = c2t_tracking_fnm , row.names = F, append = F ) }else{ # hmd data trees_hmd_ans &lt;- readr::read_csv( hmd_fnm, progress = F, show_col_types = F) } HMD extraction took a total of 203.5 minutes at processing rate of 19.53 seconds per 1,000 trees We attempted to extract HMD from 33% of our tree list, let’s see our success rate trees_hmd_ans %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(is_training_hmd) %&gt;% dplyr::mutate(pct = n/sum(n)) ## # A tibble: 2 × 3 ## is_training_hmd n pct ## &lt;lgl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 FALSE 447306 0.715 ## 2 TRUE 178072 0.285 all of the records marked as “training data” had HMD successfully extracted from the point cloud and were used to estimate a height-HMD allometry relationship that is spatially informed using the relative tree location let’s look at the training versus the modeled HMD versus height trees_hmd_ans %&gt;% dplyr::slice_sample(n = 11111) %&gt;% dplyr::arrange(desc(is_training_hmd)) %&gt;% ggplot2::ggplot(mapping = ggplot2::aes(x = tree_height_m, y = max_crown_diam_height_m, color=is_training_hmd)) + ggplot2::geom_point() + ggplot2::labs(x = &quot;tree ht. (m)&quot;, y = &quot;tree HMD (m)&quot;) + ggplot2::scale_y_continuous(breaks = scales::extended_breaks(n=12)) + ggplot2::scale_x_continuous(breaks = scales::extended_breaks(n=14)) + ggplot2::scale_color_viridis_d(option = &quot;magma&quot;, begin = 0.2, alpha = 0.7, name = &quot;is HMD\\nfrom cloud?&quot;) + ggplot2::theme_light() Let’s look at the distribution of HMD in our study area trees_hmd_ans %&gt;% ggplot2::ggplot(mapping = ggplot2::aes(x = max_crown_diam_height_m)) + ggplot2::geom_density(fill = &quot;coral&quot;, color = &quot;coral&quot;, alpha = 0.2) + ggplot2::scale_x_continuous(breaks = scales::breaks_extended(11)) + ggplot2::labs(x = &quot;tree HMD (m)&quot;, y = &quot;&quot;) + ggplot2::theme_light() + ggplot2::theme(axis.text.y = ggplot2::element_blank(), axis.ticks.y = ggplot2::element_blank()) and look at the summary statistics of HMD trees_hmd_ans$max_crown_diam_height_m %&gt;% summary() ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.000 1.259 1.766 1.752 2.127 9.360 2.8 Forest Type: trees_type() We’ll now use trees_type() to attach species information using USDA Forest Inventory and Analysis (FIA) codes. FIA Forest Type Group Code is attached to each tree in the tree list based on the spatial overlap with the Forest Type Groups of the Continental United States data (Wilson 2023). let’s get the FIA forest type group for our tree list # where should we save the file? type_fnm &lt;- file.path(c2t_process_dir, &quot;type_data.csv&quot;) type_rast_fnm &lt;- file.path(c2t_process_dir, &quot;type_rast.tif&quot;) # if we don&#39;t already have the data, run it if(!file.exists(type_fnm) || !file.exists(type_rast_fnm)){ # time it st_temp &lt;- Sys.time() # run it trees_type_ans &lt;- cloud2trees::trees_type( tree_list = treetops_sf , study_boundary = sf::st_read(file.path(c2t_process_dir, &quot;raw_las_ctg_info.gpkg&quot;)) %&gt;% sf::st_union() ) # timer mins_temp &lt;- difftime(Sys.time(),st_temp,units = &quot;mins&quot;) %&gt;% as.numeric() # save type trees_type_ans$tree_list %&gt;% sf::st_drop_geometry() %&gt;% write.csv(file = type_fnm, row.names = F, append = F) # save raster trees_type_ans$foresttype_rast %&gt;% terra::writeRaster(type_rast_fnm, overwrite=T) # save tracking readr::read_csv(c2t_tracking_fnm, progress = F, show_col_types = F) %&gt;% dplyr::mutate( timer_trees_type_mins = mins_temp ) %&gt;% write.csv( file = c2t_tracking_fnm , row.names = F, append = F ) }else{ trees_type_ans &lt;- list() # type data trees_type_ans$tree_list &lt;- readr::read_csv(type_fnm, progress = F, show_col_types = F) # raster trees_type_ans$foresttype_rast &lt;- terra::rast(type_rast_fnm) } Let’s look at the FIA Forest Type Group data we extracted for the tree list. trees_type_ans$tree_list %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(forest_type_group_code, forest_type_group) %&gt;% dplyr::arrange(desc(n)) %&gt;% dplyr::mutate(pct = n/sum(n)) %&gt;% kableExtra::kbl(caption = &quot;Count of trees by FIA Forest Type Group&quot;, digits = 2) %&gt;% kableExtra::kable_styling() Table 2.1: Count of trees by FIA Forest Type Group forest_type_group_code forest_type_group n pct 180 Pinyon / juniper group 605364 0.97 220 Ponderosa pine group 19879 0.03 970 Woodland hardwoods group 135 0.00 Let’s attach FIA Forest Types Group name to the raster (foresttype_rast) of the area we searched and plot it # load in the forest type data ext_data_temp &lt;- cloud2trees::find_ext_data() foresttype_lookup &lt;- file.path(ext_data_temp$foresttype_dir, &quot;foresttype_lookup.csv&quot;) %&gt;% readr::read_csv(progress = F, show_col_types = F) %&gt;% dplyr::distinct(forest_type_group_code, forest_type_group, hardwood_softwood) # what? foresttype_lookup %&gt;% dplyr::glimpse() ## Rows: 35 ## Columns: 3 ## $ forest_type_group_code &lt;dbl&gt; 100, 120, 140, 150, 160, 170, 180, 200, 220, 24… ## $ forest_type_group &lt;chr&gt; &quot;White / red / jack pine group&quot;, &quot;Spruce / fir … ## $ hardwood_softwood &lt;chr&gt; &quot;Softwood&quot;, &quot;Softwood&quot;, &quot;Softwood&quot;, &quot;Softwood&quot;,… plot the FIA Forest Types Group raster within the footprint of the point cloud data we processed # study area aoi_temp &lt;- sf::st_read(file.path(c2t_process_dir, &quot;raw_las_ctg_info.gpkg&quot;)) %&gt;% sf::st_transform(terra::crs(trees_type_ans$foresttype_rast)) # plot raster r_plt &lt;- trees_type_ans$foresttype_rast %&gt;% terra::crop(aoi_temp %&gt;% sf::st_buffer(5) %&gt;% terra::vect()) %&gt;% terra::as.data.frame(xy=T) %&gt;% dplyr::rename(forest_type_group_code = 3) %&gt;% dplyr::left_join(foresttype_lookup, by = &quot;forest_type_group_code&quot;) %&gt;% ggplot2::ggplot() + ggplot2::geom_tile(mapping = ggplot2::aes(x=x, y=y, fill = forest_type_group)) + ggplot2::labs(fill = &quot;FIA forest\\ntype group&quot;) + # ggplot2::scale_fill_viridis_d(option = &quot;turbo&quot;, alpha = 0.9) + harrypotter::scale_fill_hp_d(option = &quot;lunalovegood&quot;, alpha = 0.9) + ggplot2::theme_void() + ggplot2::theme(legend.position = &quot;top&quot;) + ggplot2::guides(fill = ggplot2::guide_legend(nrow = 2, byrow = T)) # add our study boundary r_plt + ggplot2::geom_sf(data = aoi_temp, color = &quot;white&quot;, fill = NA) 2.9 Combine data before our last tree component calculation, we’ll bring all of our data together because the last component relies on this data # read all of our data back in trees_dbh_temp &lt;- readr::read_csv( dbh_fnm , col_select = c( treeID, tidyselect::contains(&quot;dbh&quot;) , tidyselect::starts_with(&quot;basal_area&quot;) , tidyselect::starts_with(&quot;radius&quot;) ) , show_col_types = F , progress = F ) trees_cbh_temp &lt;- readr::read_csv( cbh_fnm , col_select = c(treeID, tree_cbh_m, is_training_cbh) , show_col_types = F , progress = F ) trees_hmd_temp &lt;- readr::read_csv( hmd_fnm , col_select = c(treeID, max_crown_diam_height_m, is_training_hmd) , show_col_types = F , progress = F ) trees_type_temp &lt;- readr::read_csv( type_fnm , col_select = c(treeID, tidyselect::starts_with(&quot;forest_type&quot;), hardwood_softwood) , show_col_types = F , progress = F ) # function re-cast treeID if needed recast_id_fn &lt;- function(df, cl) { if( !inherits( df$treeID , cl ) ){ if(cl==&quot;character&quot;){ df$treeID &lt;- format(df$treeID, scientific = F, trim = T) %&gt;% as.character() %&gt;% stringr::str_squish() }else if(cl==&quot;numeric&quot;){ df$treeID &lt;- as.numeric(df$treeID) } } return(df) } # apply trees_dbh_temp &lt;- trees_dbh_temp %&gt;% recast_id_fn(cl = class(treetops_sf$treeID)) trees_cbh_temp &lt;- trees_cbh_temp %&gt;% recast_id_fn(cl = class(treetops_sf$treeID)) trees_hmd_temp &lt;- trees_hmd_temp %&gt;% recast_id_fn(cl = class(treetops_sf$treeID)) trees_type_temp &lt;- trees_type_temp %&gt;% recast_id_fn(cl = class(treetops_sf$treeID)) # now we&#39;ll get a list of the columns in our component data to drop from our main data cols_to_drop_temp &lt;- c( names(trees_dbh_temp), names(trees_cbh_temp) , names(trees_hmd_temp), names(trees_type_temp) ) %&gt;% unique() %&gt;% setdiff(&quot;treeID&quot;) # remove cols from our primary data treetops_sf &lt;- treetops_sf %&gt;% dplyr::select( -dplyr::any_of(cols_to_drop_temp)) # join altogether using the magical purrr::reduce treetops_sf &lt;- list( treetops_sf, trees_dbh_temp, trees_cbh_temp , trees_hmd_temp, trees_type_temp ) %&gt;% purrr::reduce(\\(x,y) dplyr::left_join(x, y, by = &quot;treeID&quot;)) let’s glimpse our almost final data treetops_sf %&gt;% dplyr::glimpse() ## Rows: 625,378 ## Columns: 23 ## $ treeID &lt;chr&gt; &quot;270511_706700.2_4193508&quot;, &quot;273702_706701.7_41… ## $ tree_height_m &lt;dbl&gt; 1.88, 4.37, 2.00, 6.13, 3.21, 4.08, 4.67, 5.79… ## $ tree_x &lt;dbl&gt; 706700.2, 706701.7, 706702.2, 706702.4, 706703… ## $ tree_y &lt;dbl&gt; 4193508, 4193500, 4193498, 4193502, 4193468, 4… ## $ crown_area_m2 &lt;dbl&gt; 0.5000, 4.6250, 1.1250, 5.7500, 1.5625, 2.8750… ## $ fia_est_dbh_cm &lt;dbl&gt; 7.301241, 25.495789, 8.026274, 34.120251, 17.0… ## $ fia_est_dbh_cm_lower &lt;dbl&gt; 3.237763, 11.244682, 3.579261, 15.115603, 7.47… ## $ fia_est_dbh_cm_upper &lt;dbl&gt; 13.69907, 47.82657, 14.77090, 63.38588, 31.738… ## $ dbh_cm &lt;dbl&gt; 7.301241, 25.495789, 8.026274, 34.120251, 17.0… ## $ dbh_m &lt;dbl&gt; 0.07301241, 0.25495789, 0.08026274, 0.34120251… ## $ ptcld_extracted_dbh_cm &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… ## $ ptcld_predicted_dbh_cm &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA… ## $ basal_area_m2 &lt;dbl&gt; 0.004186810, 0.051053648, 0.005059619, 0.09143… ## $ basal_area_ft2 &lt;dbl&gt; 0.04506683, 0.54954146, 0.05446174, 0.98421050… ## $ radius_m &lt;dbl&gt; 0.03650621, 0.12747894, 0.04013137, 0.17060125… ## $ tree_cbh_m &lt;dbl&gt; 1.667434, 2.422139, 1.701111, 3.307433, 2.1237… ## $ is_training_cbh &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALS… ## $ max_crown_diam_height_m &lt;dbl&gt; 1.030000, 2.256222, 1.106201, 2.120000, 1.4513… ## $ is_training_hmd &lt;lgl&gt; TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, … ## $ forest_type_group_code &lt;dbl&gt; 180, 180, 180, 180, 180, 180, 180, 180, 180, 1… ## $ forest_type_group &lt;chr&gt; &quot;Pinyon / juniper group&quot;, &quot;Pinyon / juniper gr… ## $ hardwood_softwood &lt;chr&gt; &quot;Softwood&quot;, &quot;Softwood&quot;, &quot;Softwood&quot;, &quot;Softwood&quot;… ## $ geometry &lt;POINT [m]&gt; POINT (706700.2 4193508), POINT (706701.… 2.10 Crown Biomass: trees_biomass() Lastly, we’ll use trees_biomass() to estimate tree crown biomass in kilograms. We’ll estimate biomass based on: 1) LANDFIRE’s Forest Canopy Bulk Density (CBD) data; and 2) based on the Cruz et al. (2003) equations and the FIA forest type group we got above # where should we save the file? biomass_fnm &lt;- file.path(c2t_process_dir,&quot;biomass_data.csv&quot;) # if we don&#39;t already have the data, run it if(!file.exists(biomass_fnm)){ # time it st_temp &lt;- Sys.time() # run it trees_biomass_ans &lt;- cloud2trees::trees_biomass( tree_list = treetops_sf , method = c(&quot;cruz&quot;,&quot;landfire&quot;) , study_boundary = sf::st_read(file.path(c2t_process_dir,&quot;raw_las_ctg_info.gpkg&quot;)) %&gt;% sf::st_union() ) # timer mins_temp &lt;- difftime(Sys.time(),st_temp,units = &quot;mins&quot;) %&gt;% as.numeric() # save biomass trees_biomass_ans$tree_list %&gt;% sf::st_drop_geometry() %&gt;% write.csv(file = biomass_fnm, row.names = F, append = F) # save raster df trees_biomass_ans$stand_cell_data_landfire %&gt;% sf::st_drop_geometry() %&gt;% write.csv(file = file.path(c2t_process_dir,&quot;stand_cell_data_landfire.csv&quot;), row.names = F, append = F) trees_biomass_ans$stand_cell_data_cruz %&gt;% sf::st_drop_geometry() %&gt;% write.csv(file = file.path(c2t_process_dir,&quot;stand_cell_data_cruz.csv&quot;), row.names = F, append = F) # save tracking readr::read_csv(c2t_tracking_fnm, progress = F, show_col_types = F) %&gt;% dplyr::mutate( timer_trees_biomass_mins = mins_temp ) %&gt;% write.csv( file = c2t_tracking_fnm , row.names = F, append = F ) }else{ trees_biomass_ans &lt;- list() # biomass data trees_biomass_ans$tree_list &lt;- readr::read_csv(biomass_fnm, progress = F, show_col_types = F) # raster trees_biomass_ans$stand_cell_data_landfire &lt;- readr::read_csv(file = file.path(c2t_process_dir,&quot;stand_cell_data_landfire.csv&quot;), progress = F, show_col_types = F) trees_biomass_ans$stand_cell_data_cruz &lt;- readr::read_csv(file = file.path(c2t_process_dir,&quot;stand_cell_data_cruz.csv&quot;), progress = F, show_col_types = F) } Tree crown biomass estimation took a total of 5.2 minutes at processing rate of 0.35 seconds per hectare let’s look at the summary of the tree crown bulk density (CBD) values and the resulting crown biomass trees_biomass_ans$tree_list %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(tidyselect::ends_with(&quot;tree_kg_per_m3&quot;), tidyselect::ends_with(&quot;crown_biomass_kg&quot;)) %&gt;% summary() ## cruz_tree_kg_per_m3 landfire_tree_kg_per_m3 cruz_crown_biomass_kg ## Min. :0.4 Min. :0.09936 Min. : 0.0 ## 1st Qu.:0.9 1st Qu.:0.53931 1st Qu.: 1.4 ## Median :1.0 Median :0.70857 Median : 4.4 ## Mean :1.0 Mean :0.75114 Mean : 8.7 ## 3rd Qu.:1.2 3rd Qu.:0.89114 3rd Qu.: 11.4 ## Max. :2.0 Max. :1.99737 Max. :435.6 ## NA&#39;s :605499 NA&#39;s :605499 ## landfire_crown_biomass_kg ## Min. : 0.0013 ## 1st Qu.: 0.8059 ## Median : 2.5805 ## Mean : 5.6171 ## 3rd Qu.: 6.6420 ## Max. :793.2737 ## note those NA values for the Cruz et al. (2003) method, these NA values are introduced because this particular methodology is limited to the forest types for which biomass equations exist check out the break-down by FIA forest type group trees_biomass_ans$tree_list %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(!is.na(forest_type_group)) %&gt;% dplyr::group_by(forest_type_group) %&gt;% dplyr::summarise( n = dplyr::n() , dplyr::across( cruz_tree_kg_per_m3 , .fns = list(mean = mean, sd = sd, min = min, max = max) ) ) %&gt;% dplyr::rename_with(~ stringr::str_remove_all(.x,&quot;cruz_tree_kg_per_m3_&quot;)) %&gt;% dplyr::arrange(desc(n)) %&gt;% kableExtra::kbl(caption = &quot;Summary of tree CBD (kg per m3) by FIA Forest Type Group&quot;, digits = 2) %&gt;% kableExtra::kable_styling() Table 2.2: Summary of tree CBD (kg per m3) by FIA Forest Type Group forest_type_group n mean sd min max Pinyon / juniper group 605364 NA NA NA NA Ponderosa pine group 19879 1.04 0.27 0.36 1.99 Woodland hardwoods group 135 NA NA NA NA Let’s check the distribution of CBD values estimated in our study area but only for trees that had both Cruz et al. (2003) and LANDFIRE estimates trees_biomass_ans$tree_list %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(tidyselect::ends_with(&quot;tree_kg_per_m3&quot;)) %&gt;% dplyr::filter(!dplyr::if_any(.cols = dplyr::everything(), .fns = ~is.na(.x))) %&gt;% tidyr::pivot_longer(cols = tidyselect::everything()) %&gt;% dplyr::mutate(name = stringr::str_remove_all(name,&quot;_tree_kg_per_m3&quot;)) %&gt;% ggplot2::ggplot(ggplot2::aes(x = value, color = name, fill = name)) + ggplot2::geom_density() + ggplot2::facet_grid(cols = dplyr::vars(name)) + ggplot2::scale_fill_viridis_d(option = &quot;turbo&quot;, begin = 0.3, end = 0.7, alpha = 0.7, name = &quot;biomass method&quot;) + ggplot2::scale_color_viridis_d(option = &quot;turbo&quot;, begin = 0.3, end = 0.7,name = &quot;biomass method&quot;) + ggplot2::scale_x_continuous(breaks = scales::breaks_extended(8)) + ggplot2::labs(x = &quot;tree kilograms per cubic meter&quot;, y = &quot;&quot;) + ggplot2::theme_light() + ggplot2::theme(legend.position = &quot;none&quot;) We can see how the LANDFIRE Forest Canopy Bulk Density (CBD) data and Cruz et al. (2003) methodologies compare at estimating tree crown biomass for our study area we’ll make this comparison only for trees that have biomass estimated using the Cruz method as well # set the upper limit scale ul_temp &lt;- max( quantile(trees_biomass_ans$tree_list$cruz_crown_biomass_kg, probs = 0.95, na.rm = T) , quantile(trees_biomass_ans$tree_list$landfire_crown_biomass_kg, probs = 0.95, na.rm = T) ) # plot tree landfire vs. cruz crown biomass estimate trees_biomass_ans$tree_list %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(!is.na(cruz_crown_biomass_kg)) %&gt;% dplyr::slice_sample(n=11111) %&gt;% ggplot2::ggplot( mapping = ggplot2::aes( x = landfire_crown_biomass_kg, y = cruz_crown_biomass_kg ) ) + ggplot2::geom_abline(lwd = 1.5) + ggplot2::geom_point(ggplot2::aes(color = tree_height_m)) + ggplot2::geom_smooth(method = &quot;lm&quot;, se=F, color = &quot;tomato&quot;, linetype = &quot;dashed&quot;) + ggplot2::scale_color_viridis_c(option = &quot;mako&quot;, direction = -1, alpha = 0.8) + ggplot2::scale_x_continuous(limits = c(0, ul_temp)) + ggplot2::scale_y_continuous(limits = c(0, ul_temp)) + ggplot2::labs( x = &quot;LANDFIRE crown biomass (kg)&quot; , y = &quot;Cruz crown biomass (kg)&quot; , color = &quot;tree ht. (m)&quot; ) + ggplot2::theme_light() we can summarize the average difference between the two methods for records with both estimates trees_biomass_ans$tree_list %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(!is.na(cruz_crown_biomass_kg)) %&gt;% dplyr::mutate( diff_cruz_lf_kg = cruz_crown_biomass_kg-landfire_crown_biomass_kg , pct_diff_cruz_lf_kg = diff_cruz_lf_kg/landfire_crown_biomass_kg ) %&gt;% dplyr::summarise( dplyr::across( c(cruz_crown_biomass_kg,landfire_crown_biomass_kg,diff_cruz_lf_kg,pct_diff_cruz_lf_kg) , .fns = list(mean = mean) , .names = &quot;{.fn}_{.col}&quot; ) ) %&gt;% dplyr::mutate( mean_pct_diff_cruz_lf_kg = scales::percent(mean_pct_diff_cruz_lf_kg, accuracy = 0.1) , dplyr::across( .cols = -mean_pct_diff_cruz_lf_kg , .fns = ~scales::comma(.x,accuracy = 0.01) ) ) %&gt;% tidyr::pivot_longer(tidyselect::everything()) %&gt;% kableExtra::kbl(caption = &quot;Mean difference between LANDFIRE and Cruz estimated tree crown biomass in kilograms&quot;, digits = 2) %&gt;% kableExtra::kable_styling() Table 2.3: Mean difference between LANDFIRE and Cruz estimated tree crown biomass in kilograms name value mean_cruz_crown_biomass_kg 8.65 mean_landfire_crown_biomass_kg 5.22 mean_diff_cruz_lf_kg 3.43 mean_pct_diff_cruz_lf_kg 130.9% Finally, let’s plot the spatial arrangement of estimated biomass using the raster data returned from trees_biomass() First, for LANDFIRE # aoi aoi_temp &lt;- sf::st_read(&quot;../data/point_cloud_processing_delivery/raw_las_ctg_info.gpkg&quot;) ## Reading layer `raw_las_ctg_info&#39; from data source ## `C:\\Data\\usfs\\blm_trfo_uas\\data\\point_cloud_processing_delivery\\raw_las_ctg_info.gpkg&#39; ## using driver `GPKG&#39; ## Simple feature collection with 156 features and 34 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 706698.8 ymin: 4191874 xmax: 710919.1 ymax: 4194616 ## Projected CRS: NAD83(2011) / UTM zone 12N # get the projection for the stand cell data epsg_code_temp &lt;- trees_biomass_ans$stand_cell_data_landfire$rast_epsg_code[1] %&gt;% as.numeric() # set the color limit ul_temp &lt;- max( max(trees_biomass_ans$stand_cell_data_landfire$landfire_stand_kg_per_m3, na.rm = T) , max(trees_biomass_ans$stand_cell_data_cruz$cruz_stand_kg_per_m3, na.rm = T) ) # plot the stand cell data with trees overlaid trees_biomass_ans$stand_cell_data_landfire %&gt;% dplyr::filter(trees&gt;0) %&gt;% ggplot2::ggplot() + ggplot2::geom_tile(ggplot2::aes(x=x,y=y,fill = landfire_stand_kg_per_m3), color = NA) + ggplot2::geom_sf(data = aoi_temp %&gt;% sf::st_transform(crs = epsg_code_temp), fill = NA) + ggplot2::labs(subtitle = &quot;LANDFIRE stand kg/m3&quot;, fill=&quot;LANDFIRE\\nstand kg/m3&quot;) + ggplot2::scale_fill_viridis_c( limits = c(NA,ul_temp) , option = &quot;rocket&quot;, direction = -1, na.value = &quot;white&quot; ) + ggplot2::coord_sf() + ggplot2::theme_void() and for Cruz # get the projection for the stand cell data epsg_code_temp &lt;- trees_biomass_ans$stand_cell_data_cruz$rast_epsg_code[1] %&gt;% as.numeric() # plot the stand cell data with trees overlaid trees_biomass_ans$stand_cell_data_cruz %&gt;% dplyr::filter(trees&gt;0) %&gt;% ggplot2::ggplot() + ggplot2::geom_tile(ggplot2::aes(x=x,y=y,fill = cruz_stand_kg_per_m3), color = NA) + ggplot2::geom_sf(data = aoi_temp %&gt;% sf::st_transform(crs = epsg_code_temp), fill = NA) + ggplot2::labs(subtitle = &quot;Cruz stand kg/m3&quot;, fill=&quot;Cruz\\nstand kg/m3&quot;) + ggplot2::scale_fill_viridis_c( limits = c(NA,ul_temp) , option = &quot;rocket&quot;, direction = -1, na.value = &quot;white&quot; ) + ggplot2::theme_void() 2.11 Processing Time Summary Let’s summarize how long all of this point cloud processing took and determine which steps were most computationally intensive. # aggregate the total processing time processing_data &lt;- readr::read_csv(c2t_tracking_fnm, progress = F, show_col_types = F) %&gt;% dplyr::mutate( timer_total_time_mins = timer_cloud2raster_mins + timer_raster2trees_mins + timer_trees_dbh_mins + timer_trees_cbh_mins + timer_trees_type_mins + timer_trees_hmd_mins + timer_trees_biomass_mins , timer_tree_extraction_mins = timer_cloud2raster_mins + timer_raster2trees_mins ) %&gt;% dplyr::mutate(dplyr::across( .cols = c(timer_tree_extraction_mins, timer_trees_dbh_mins, timer_trees_cbh_mins, timer_trees_type_mins, timer_trees_hmd_mins, timer_trees_biomass_mins) , .fns = ~ .x/timer_total_time_mins , .names = &quot;{.col}_pct&quot; )) # table it table_temp &lt;- processing_data %&gt;% dplyr::select( c(timer_tree_extraction_mins, timer_trees_dbh_mins, timer_trees_cbh_mins, timer_trees_type_mins, timer_trees_hmd_mins, timer_trees_biomass_mins , c(tidyselect::ends_with(&quot;_pct&quot;) &amp; tidyselect::starts_with(&quot;timer_&quot;)) ) ) %&gt;% tidyr::pivot_longer(dplyr::everything()) %&gt;% dplyr::mutate( units = stringr::word(name, -1, sep = &quot;_&quot;) , section = name %&gt;% stringr::str_remove_all(&quot;timer_&quot;) %&gt;% stringr::str_remove_all(&quot;_mins&quot;) %&gt;% stringr::str_remove_all(&quot;_pct&quot;) ) %&gt;% dplyr::select(-name) %&gt;% tidyr::pivot_wider(names_from = units, values_from = value) %&gt;% dplyr::mutate( mins_lab = scales::comma(mins,accuracy = 0.1) , pct_lab = scales::percent(pct,accuracy = 0.1) ) table it table_temp %&gt;% dplyr::select(section, tidyselect::ends_with(&quot;_lab&quot;)) %&gt;% kableExtra::kbl( caption = &quot;Point cloud processing section run time&quot; , col.names = c( &quot;Processing section&quot; , &quot;time (minutes)&quot; , &quot;% of total time&quot; ) ) %&gt;% kableExtra::kable_styling() Table 2.4: Point cloud processing section run time Processing section time (minutes) % of total time tree_extraction 340.6 38.8% trees_dbh 7.9 0.9% trees_cbh 319.6 36.4% trees_type 0.4 0.0% trees_hmd 203.5 23.2% trees_biomass 5.2 0.6% 2.12 Data Export Now that we have our point cloud-extracted tree list with all of the tree component measurements attached, let’s save the data for use in our analysis first we’ll attach the biomass metrics to our spatial tree list # new columns added by trees_biomass() names_temp &lt;- setdiff( trees_biomass_ans$tree_list %&gt;% names() , treetops_sf %&gt;% dplyr::select(!tidyselect::starts_with(&quot;cruz_&quot;)) %&gt;% dplyr::select(!tidyselect::starts_with(&quot;landfire_&quot;)) %&gt;% dplyr::select( -dplyr::any_of(c( &quot;crown_dia_m&quot;,&quot;crown_length_m&quot;,&quot;crown_volume_m3&quot; ))) %&gt;% names() ) # recast id if needed trees_biomass_ans$tree_list &lt;- trees_biomass_ans$tree_list %&gt;% recast_id_fn(cl = class(treetops_sf$treeID)) # attach to our spatial tree points treetops_sf &lt;- treetops_sf %&gt;% dplyr::select(!tidyselect::starts_with(&quot;cruz_&quot;)) %&gt;% dplyr::select(!tidyselect::starts_with(&quot;landfire_&quot;)) %&gt;% dplyr::select( -dplyr::any_of(c( &quot;crown_dia_m&quot;,&quot;crown_length_m&quot;,&quot;crown_volume_m3&quot; ))) %&gt;% dplyr::left_join( trees_biomass_ans$tree_list %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(dplyr::all_of(c(&quot;treeID&quot;, names_temp))) , by = &quot;treeID&quot; ) # what does our final data look like? treetops_sf %&gt;% dplyr::glimpse() ## Rows: 625,378 ## Columns: 34 ## $ treeID &lt;chr&gt; &quot;270511_706700.2_4193508&quot;, &quot;273702_706701.7_… ## $ tree_height_m &lt;dbl&gt; 1.88, 4.37, 2.00, 6.13, 3.21, 4.08, 4.67, 5.… ## $ tree_x &lt;dbl&gt; 706700.2, 706701.7, 706702.2, 706702.4, 7067… ## $ tree_y &lt;dbl&gt; 4193508, 4193500, 4193498, 4193502, 4193468,… ## $ crown_area_m2 &lt;dbl&gt; 0.5000, 4.6250, 1.1250, 5.7500, 1.5625, 2.87… ## $ fia_est_dbh_cm &lt;dbl&gt; 7.301241, 25.495789, 8.026274, 34.120251, 17… ## $ fia_est_dbh_cm_lower &lt;dbl&gt; 3.237763, 11.244682, 3.579261, 15.115603, 7.… ## $ fia_est_dbh_cm_upper &lt;dbl&gt; 13.69907, 47.82657, 14.77090, 63.38588, 31.7… ## $ dbh_cm &lt;dbl&gt; 7.301241, 25.495789, 8.026274, 34.120251, 17… ## $ dbh_m &lt;dbl&gt; 0.07301241, 0.25495789, 0.08026274, 0.341202… ## $ ptcld_extracted_dbh_cm &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ ptcld_predicted_dbh_cm &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ basal_area_m2 &lt;dbl&gt; 0.004186810, 0.051053648, 0.005059619, 0.091… ## $ basal_area_ft2 &lt;dbl&gt; 0.04506683, 0.54954146, 0.05446174, 0.984210… ## $ radius_m &lt;dbl&gt; 0.03650621, 0.12747894, 0.04013137, 0.170601… ## $ tree_cbh_m &lt;dbl&gt; 1.667434, 2.422139, 1.701111, 3.307433, 2.12… ## $ is_training_cbh &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA… ## $ max_crown_diam_height_m &lt;dbl&gt; 1.030000, 2.256222, 1.106201, 2.120000, 1.45… ## $ is_training_hmd &lt;lgl&gt; TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE… ## $ forest_type_group_code &lt;dbl&gt; 180, 180, 180, 180, 180, 180, 180, 180, 180,… ## $ forest_type_group &lt;chr&gt; &quot;Pinyon / juniper group&quot;, &quot;Pinyon / juniper … ## $ hardwood_softwood &lt;chr&gt; &quot;Softwood&quot;, &quot;Softwood&quot;, &quot;Softwood&quot;, &quot;Softwoo… ## $ cruz_stand_id &lt;dbl&gt; 8933, 9119, 9119, 9119, 9305, 9305, 9119, 91… ## $ cruz_tree_kg_per_m3 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ cruz_stand_kg_per_m3 &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ cruz_crown_biomass_kg &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ landfire_stand_id &lt;dbl&gt; 4594, 4594, 4594, 4594, 4742, 4742, 4594, 45… ## $ crown_dia_m &lt;dbl&gt; 0.7978846, 2.4266712, 1.1968268, 2.7057582, … ## $ crown_length_m &lt;dbl&gt; 0.2125661, 1.9478610, 0.2988889, 2.8225668, … ## $ crown_volume_m3 &lt;dbl&gt; 0.07085537, 6.00590471, 0.22416667, 10.81983… ## $ landfire_tree_kg_per_m3 &lt;dbl&gt; 0.7581083, 0.7581083, 0.7581083, 0.7581083, … ## $ landfire_stand_kg_per_m3 &lt;dbl&gt; 0.27, 0.27, 0.27, 0.27, 0.27, 0.27, 0.27, 0.… ## $ landfire_crown_biomass_kg &lt;dbl&gt; 0.05371604, 4.55312599, 0.16994260, 8.202609… ## $ geometry &lt;POINT [m]&gt; POINT (706700.2 4193508), POINT (70670… # where should we save the file? treetops_fnm &lt;- file.path(c2t_process_dir,&quot;final_detected_tree_tops_attr.gpkg&quot;) # if we don&#39;t already have the data, run it if(!file.exists(treetops_fnm)){ treetops_sf %&gt;% sf::st_write(dsn = treetops_fnm, append = FALSE, quiet = TRUE) } "],["slash-piles.html", "Section 3 Slash Piles 3.1 Slash Pile Detection Workflow 3.2 Candidate Pile Review 3.3 Slash Pile Summary Statistics", " Section 3 Slash Piles In this section, we’re going to detect slash piles from the CHM over the data extent and use RGB data to spectrally refine pile predictions. The objective is to use pile predictions as a mask to remove smaller, detected “trees” that are actually piles or downed trees/debris. 3.1 Slash Pile Detection Workflow make sure we have the fine-resolution CHM and RGB data ready to go RGB # hey rgb rgb_rast &lt;- terra::rast(rgb_rast_fnm) %&gt;% terra::subset(c(1,2,3)) rgb_rast ## class : SpatRaster ## size : 105962, 163076, 3 (nrow, ncol, nlyr) ## resolution : 0.025883, 0.025883 (x, y) ## extent : 706698.8, 710919.7, 4191874, 4194616 (xmin, xmax, ymin, ymax) ## coord. ref. : NAD83(2011) / UTM zone 12N (EPSG:6341) ## source : BLM_CO_SWDF_DawsonFuelsTreatment_Ortho_202504.tif ## names : Red, Green, Blue # terra::plotRGB(rgb_rast) CHM # fine-resolution CHM raster chm_rast &lt;- terra::rast( file.path(c2t_process_dir, &quot;chm_0.1m.tif&quot;) ) chm_rast ## class : SpatRaster ## size : 27426, 42203, 1 (nrow, ncol, nlyr) ## resolution : 0.1, 0.1 (x, y) ## extent : 706698.8, 710919.1, 4191874, 4194616 (xmin, xmax, ymin, ymax) ## coord. ref. : NAD83(2011) / UTM zone 12N (EPSG:6341) ## source : chm_0.1m.tif ## name : focal_mean ## min value : 0.00 ## max value : 22.59 # chm_rast %&gt;% terra::plot(col = viridis::plasma(n=100), main = &quot;CHM (m)&quot;) load the treatment unit boundaries stand_boundary &lt;- sf::st_read(&quot;d:/BLM_CO_SWDF_DawsonFuelsTreatment/units/units.shp&quot;, quiet=T) %&gt;% dplyr::rename_with(tolower) %&gt;% dplyr::rename_with(stringr::str_squish) %&gt;% dplyr::rename_with(make.names) %&gt;% dplyr::rename_with(~stringr::str_replace_all(.x, &quot;\\\\.{2,}&quot;, &quot;.&quot;)) %&gt;% dplyr::rename_with(~stringr::str_remove(.x, &quot;\\\\.$&quot;)) %&gt;% dplyr::rename_with(~stringr::str_replace_all(.x, &quot;\\\\.&quot;, &quot;_&quot;)) %&gt;% sf::st_set_geometry(&quot;geometry&quot;) %&gt;% sf::st_transform(terra::crs(chm_rast)) %&gt;% dplyr::mutate( unit_ha = as.numeric(sf::st_area(geometry))/10000 ) # stand_boundary %&gt;% dplyr::glimpse() what treatments are there? stand_boundary %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(tretmnt) ## tretmnt n ## 1 Control 12 ## 2 Heterogenous 12 ## 3 Uniform- HIgh 12 ## 4 Uniform- Low 12 plot the stands on the CHM chm_rast %&gt;% # terra::aggregate(fact = 2, fun=&quot;max&quot;,na.rm=T,cores=lasR::half_cores()) %&gt;% terra::plot(col = viridis::plasma(n=100), main = &quot;CHM (m)&quot;, axes = F) terra::plot( stand_boundary %&gt;% terra::vect() , add = T, border = &quot;black&quot;, col = NA, lwd = 1.5 ) # stand_boundary %&gt;% # dplyr::ungroup() %&gt;% # sf::st_union() %&gt;% # sf::st_convex_hull() %&gt;% # sf::st_buffer(25) %&gt;% # terra::vect() %&gt;% # terra::plot( # add = T, border = &quot;red&quot;, col = NA, lwd = 2 # ) let’s crop the RGB and CHM to limit the amount of data we need to process we’ll also make the RGB data more coarse since we only need ~0.06-0.1 m resolution data for the spectral filtering step in the pile detection workflow # outside boundary of stand units with buffer crop_bound_temp &lt;- stand_boundary %&gt;% dplyr::ungroup() %&gt;% sf::st_union() %&gt;% sf::st_convex_hull() %&gt;% sf::st_buffer(25) ## function to change the resolution of RGB change_res_fn &lt;- function( r , my_res=1 , m = &quot;bilinear&quot; # , ofile = tempfile(fileext = &quot;.tif&quot;) , ofile = NULL ){ if(terra::res(r)[1] == my_res){ return(r) }else{ r2 &lt;- r terra::res(r2) &lt;- my_res if(!inherits(ofile,&quot;character&quot;)){ r2 &lt;- terra::resample(r, r2, method = m) }else{ r2 &lt;- terra::resample(r, r2, method = m, filename=ofile, overwrite = T) } return(r2) } } ############################################################### # clip rgb to boundary and resample to change resolution ############################################################### dir_temp &lt;- c2t_process_dir rgb_fnm_temp &lt;- file.path(dir_temp,&quot;pj_rgb_rast.tif&quot;) # what should the compiled rgb be called? if(!dir.exists(dir_temp)){dir.create(dir_temp, showWarnings = F)} if(!file.exists(rgb_fnm_temp)){ # Crop the raster to the rectangular extent of the polygon # Specify a filename to ensure the result is written to disk crop_rgb_rast_temp &lt;- rgb_rast %&gt;% terra::crop( crop_bound_temp %&gt;% terra::vect() %&gt;% terra::project(terra::crs(rgb_rast)) , filename = tempfile(fileext = &quot;.tif&quot;) , mask = T , overwrite = TRUE ) ## apply the change_res_fn for our analysis we don&#39;t need such finery # this takes too long... rgb_rast &lt;- change_res_fn(rgb_rast, my_res=0.06, ofile = rgb_fnm_temp) }else{ rgb_rast &lt;- terra::rast(rgb_fnm_temp) } ############################################################### # clip chm to boundary ############################################################### chm_fnm_temp &lt;- file.path(dir_temp, paste0(&quot;crop_&quot;,basename(terra::sources(chm_rast))) ) # what should the compiled rgb be called? if(!dir.exists(dir_temp)){dir.create(dir_temp, showWarnings = F)} if(!file.exists(chm_fnm_temp)){ # Crop the raster to the rectangular extent of the polygon # Specify a filename to ensure the result is written to disk chm_rast &lt;- chm_rast %&gt;% terra::crop( crop_bound_temp %&gt;% terra::vect() %&gt;% terra::project(terra::crs(chm_rast)) , filename = chm_fnm_temp , mask = T , overwrite = TRUE ) }else{ chm_rast &lt;- terra::rast(chm_fnm_temp) } check the new raster data rgb_rast ## class : SpatRaster ## size : 45710, 70348, 3 (nrow, ncol, nlyr) ## resolution : 0.06, 0.06 (x, y) ## extent : 706698.8, 710919.7, 4191874, 4194616 (xmin, xmax, ymin, ymax) ## coord. ref. : NAD83(2011) / UTM zone 12N (EPSG:6341) ## source : pj_rgb_rast.tif ## names : Red, Green, Blue ## min values : 0.0000, 0.0000, 0.0000 ## max values : 253.1589, 251.0938, 248.0194 chm_rast ## class : SpatRaster ## size : 25292, 39925, 1 (nrow, ncol, nlyr) ## resolution : 0.1, 0.1 (x, y) ## extent : 706801.4, 710793.9, 4192002, 4194532 (xmin, xmax, ymin, ymax) ## coord. ref. : NAD83(2011) / UTM zone 12N (EPSG:6341) ## source : crop_chm_0.1m.tif ## name : focal_mean ## min value : 0.00 ## max value : 22.59 run the piles detection workflow using cloud2trees:::piles_workflow(); note, the ::: implies the functionality is internal to the package fnm_temp &lt;- file.path(c2t_process_dir,&quot;piles_detect.gpkg&quot;) if(!file.exists(fnm_temp)){ piles_workflow_ans &lt;- cloud2trees:::piles_workflow( chm_rast = chm_rast , seg_method = &quot;watershed&quot; , min_ht_m = 0.75 , max_ht_m = 3.0 , min_area_m2 = 2.0 , max_area_m2 = 22.5 , min_convexity_ratio = 0.55 , min_circularity_ratio = 0.35 , smooth_segs = T , outfile = fnm_temp , spectral_weight = 5 , rgb_rast = rgb_rast , red_band_idx = 1 , green_band_idx = 2 , blue_band_idx = 3 , filter_return = F ) # just get the piles piles_workflow_ans &lt;- piles_workflow_ans$segs_sf }else{ piles_workflow_ans &lt;- sf::st_read(fnm_temp, quiet = T) } 3.2 Candidate Pile Review we should have gotten a list of candidate slash pile locations which we’ll spectrally filter after we look at a few examples piles_workflow_ans %&gt;% dplyr::glimpse() ## Rows: 50,886 ## Columns: 22 ## $ pred_id &lt;dbl&gt; 3, 68, 75, 143, 151, 178, 227, 229, 343, 366, 510, … ## $ convexity_ratio &lt;dbl&gt; 0.6850095, 0.7985560, 0.8740648, 0.8054011, 0.69533… ## $ circularity_ratio &lt;dbl&gt; 0.4366637, 0.4346449, 0.4641106, 0.4544880, 0.41981… ## $ area_m2 &lt;dbl&gt; 5.270, 6.925, 8.020, 6.295, 5.465, 3.465, 10.045, 2… ## $ volume_m3 &lt;dbl&gt; 12.931723, 15.023012, 12.628348, 10.460978, 12.5403… ## $ max_height_m &lt;dbl&gt; 3.000000, 2.930000, 2.830000, 3.000000, 3.000000, 3… ## $ volume_per_area &lt;dbl&gt; 2.4538374, 2.1693880, 1.5746070, 1.6617915, 2.29465… ## $ diameter_m &lt;dbl&gt; 3.238827, 3.900000, 4.386342, 3.769615, 3.395585, 2… ## $ rast_agg_grvi &lt;dbl&gt; 1.852449e-02, 1.391539e-02, 6.146593e-03, -2.349146… ## $ rast_agg_rgri &lt;dbl&gt; 0.9636249, 0.9725512, 0.9877819, 1.0000470, 1.00835… ## $ rast_agg_vdvi &lt;dbl&gt; 0.044285724, 0.060734405, 0.066752846, 0.014706555,… ## $ rast_agg_exgr &lt;dbl&gt; -0.065313345, -0.045324605, -0.049583234, -0.116836… ## $ rast_agg_Lab_a &lt;dbl&gt; -4.0581156, -5.5319379, -5.4390111, -0.9861935, -1.… ## $ rast_agg_hsv_hue &lt;dbl&gt; 74.35908, 67.03060, 62.75708, 68.82339, 56.30680, 6… ## $ inrange_th_grvi &lt;int&gt; 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, … ## $ inrange_th_rgri &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … ## $ inrange_th_vdvi &lt;int&gt; 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, … ## $ inrange_th_exgr &lt;int&gt; 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … ## $ inrange_th_Lab_a &lt;int&gt; 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, … ## $ inrange_th_hsv_hue &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, … ## $ inrange_th_votes &lt;dbl&gt; 3, 2, 2, 5, 4, 3, 1, 6, 2, 4, 2, 6, 5, 6, 4, 2, 6, … ## $ geom &lt;POLYGON [m]&gt; POLYGON ((708386.8 4194402,..., POLYGON ((7… lets zoom-in on a single stand to look at the candidate pile locations in blue within the unit on the CHM chm_rast %&gt;% terra::crop( stand_boundary %&gt;% dplyr::filter(tolower(tretmnt)!=&quot;control&quot;) %&gt;% dplyr::slice(1) %&gt;% sf::st_transform(terra::crs(chm_rast)) %&gt;% sf::st_buffer(5) %&gt;% terra::vect() ) %&gt;% terra::plot(col = viridis::plasma(n=100), main = &quot;CHM (m)&quot;, axes = F) terra::plot( stand_boundary %&gt;% dplyr::filter(tolower(tretmnt)!=&quot;control&quot;) %&gt;% dplyr::slice(1) %&gt;% terra::vect() , add = T, border = &quot;black&quot;, col = NA, lwd = 1.5 ) piles_workflow_ans %&gt;% dplyr::filter(inrange_th_votes&gt;=6) %&gt;% dplyr::inner_join( piles_workflow_ans %&gt;% sf::st_point_on_surface() %&gt;% sf::st_transform(sf::st_crs(stand_boundary)) %&gt;% sf::st_intersection( stand_boundary %&gt;% dplyr::filter(tolower(tretmnt)!=&quot;control&quot;) %&gt;% dplyr::slice(1) ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(pred_id) , by = &quot;pred_id&quot; ) %&gt;% sf::st_transform(terra::crs(chm_rast)) %&gt;% terra::vect() %&gt;% terra::plot( add = T, border = &quot;cyan&quot;, col = NA, lwd = 1.8 ) filter for piles only in treatment units since we don’t expect piles in non-treated areas piles_workflow_ans &lt;- piles_workflow_ans %&gt;% dplyr::left_join( piles_workflow_ans %&gt;% # pile determined in unit based on polygon center sf::st_point_on_surface() %&gt;% sf::st_transform(sf::st_crs(stand_boundary)) %&gt;% sf::st_intersection( stand_boundary %&gt;% dplyr::select(unit,block,tretmnt,unit_ha) %&gt;% dplyr::rename(type = tretmnt) %&gt;% dplyr::mutate( type = tolower(type) %&gt;% stringr::str_squish() ) %&gt;% dplyr::rename_with(.fn = ~paste0(&quot;trtmnt_&quot;, .x, recycle0 = T)) ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(pred_id, tidyselect::starts_with(&quot;trtmnt_&quot;)) , by = &quot;pred_id&quot; ) %&gt;% dplyr::mutate( is_in_trtmnt_unit = ifelse(is.na(trtmnt_type) | trtmnt_type==&quot;control&quot;,F,T) ) quick summary by treatment type piles_workflow_ans %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(is_in_trtmnt_unit, trtmnt_type) ## is_in_trtmnt_unit trtmnt_type n ## 1 FALSE control 9615 ## 2 FALSE &lt;NA&gt; 28439 ## 3 TRUE heterogenous 7084 ## 4 TRUE uniform- high 2276 ## 5 TRUE uniform- low 3474 let’s look at some candidate piles based on the inrange_th_votes variable which tells us how many of the 6 spectral index thresholds were met to distinguish a dead wood from living biomass. Where, a value of 5-6 represents high likelihood that the object is not living vegetation (e.g. piled slash) and 1-2 indicates a high likelihood that the object is living vegetation (e.g. small tree/shrub) # sample from inrange_th_votes inunit_piles_temp &lt;- piles_workflow_ans %&gt;% dplyr::filter(is_in_trtmnt_unit) %&gt;% dplyr::group_by(inrange_th_votes) %&gt;% # dplyr::filter(inrange_th_votes&gt;=6) %&gt;% dplyr::slice_sample(n = 5) %&gt;% sf::st_transform(terra::crs(rgb_rast)) %&gt;% dplyr::ungroup() %&gt;% dplyr::arrange(inrange_th_votes) # map over to plot plts_temp &lt;- 1:nrow(inunit_piles_temp) %&gt;% purrr::map(function(x){ sp_temp &lt;- inunit_piles_temp %&gt;% dplyr::slice(x) rgb_temp &lt;- rgb_rast %&gt;% terra::crop( sp_temp %&gt;% sf::st_point_on_surface() %&gt;% sf::st_buffer(8) %&gt;% sf::st_bbox() %&gt;% sf::st_as_sfc() %&gt;% terra::vect() ) # convert raster to a data frame and create hex colors # ?grDevices::rgb rgb_df_temp &lt;- rgb_temp %&gt;% terra::as.data.frame(xy = TRUE) %&gt;% dplyr::rename( red = 3, green = 4, blue = 5 ) %&gt;% dplyr::mutate( # rows that have missing color data is_missing = is.na(red) | is.na(green) | is.na(blue) # hex using 0s for NAs to avoid grDevices::rgb error , hex_col = grDevices::rgb( ifelse(is_missing, 0, red) , ifelse(is_missing, 0, green) , ifelse(is_missing, 0, blue) , maxColorValue = 255 ) # back to NA , hex_col = ifelse(is_missing, as.character(NA), hex_col) ) %&gt;% dplyr::select(-c(is_missing)) # plt plt &lt;- ggplot2::ggplot() + # add rgb base map ggplot2::geom_tile(data = rgb_df_temp, mapping = ggplot2::aes(x = x, y = y, fill = hex_col), color = NA) + # use identity scale so the hex codes are used directly ggplot2::scale_fill_identity(na.value = &quot;transparent&quot;) + # !!! don&#39;t take this out or RGB plot will kill your computer ggplot2::geom_sf( data = sp_temp , color = &quot;cyan&quot;, fill = NA, lwd = 1.5 ) + ggplot2::scale_x_continuous(expand = c(0, 0)) + ggplot2::scale_y_continuous(expand = c(0, 0)) + ggplot2::coord_sf(expand = F) + ggplot2::theme_void() + ggplot2::theme( legend.position = &quot;none&quot; ) return(plt) }) # plts_temp[[1]] plot with patchwork wplts_temp &lt;- patchwork::wrap_plots(plts_temp, ncol = 5, nrow = 6) + patchwork::plot_annotation( tag_levels = list( # as.vector(rbind(paste(&quot;Spectral Thrshlds Met&quot;, 1:6), matrix(&quot;&quot;, nrow = 4, ncol = 6))) rep(&quot;&quot;, 30) %&gt;% replace(seq(3, 30, by = 5), paste(&quot;Spectral Thrshlds Met&quot;, 1:6)) ) ) &amp; ggplot2::theme( plot.tag.position = &quot;top&quot; , plot.tag = ggplot2::element_text(size = 10, face = &quot;bold&quot;, hjust = 0.5) ) # huh? wplts_temp based on this visual inspection, we’ll use all detected piles that meet at least 5 thresholds for our mask to remove detected “trees” that are likely not trees 3.3 Slash Pile Summary Statistics first we’ll plot the slash piles in a treatment unit overlaid on the CHM unt_temp &lt;- piles_workflow_ans %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter(is_in_trtmnt_unit) %&gt;% dplyr::distinct(trtmnt_type,trtmnt_block,trtmnt_unit) %&gt;% dplyr::arrange(trtmnt_type,trtmnt_block,trtmnt_unit) plts_temp &lt;- 1:nrow(unt_temp) %&gt;% purrr::map(function(x){ unit_temp &lt;- stand_boundary %&gt;% dplyr::filter( unit == unt_temp$trtmnt_unit[x] , block == unt_temp$trtmnt_block[x] , stringr::str_squish(tolower(tretmnt)) == unt_temp$trtmnt_type[x] ) %&gt;% sf::st_transform(terra::crs(chm_rast)) piles_temp &lt;- piles_workflow_ans %&gt;% dplyr::inner_join( unt_temp %&gt;% dplyr::slice(x) , by = dplyr::join_by(trtmnt_type,trtmnt_block,trtmnt_unit) ) %&gt;% dplyr::filter( is_in_trtmnt_unit ,inrange_th_votes&gt;=5 ) chm_temp &lt;- chm_rast %&gt;% terra::crop( unit_temp %&gt;% sf::st_buffer(5) %&gt;% terra::vect() , mask = T ) %&gt;% terra::aggregate(fact=2, fun = &quot;max&quot;, na.rm = T) %&gt;% terra::as.data.frame(xy=T) %&gt;% dplyr::rename(f = 3) # plt ggplot2::ggplot() + ggplot2::geom_tile( data = chm_temp , mapping = ggplot2::aes(x=x,y=y,fill=f) , color = NA ) + ggplot2::scale_fill_viridis_c( option = &quot;plasma&quot;, alpha = 0.8 , limits = c(0,floor(terra::minmax(chm_rast)[2]*1.02)) ) + ggplot2::geom_sf(data = unit_temp, fill = NA, color = &quot;black&quot;, lwd = 0.8) + ggplot2::geom_sf( data = piles_temp , fill = NA, color = &quot;cyan&quot;, lwd = 0.3 ) + ggplot2::labs( subtitle = paste0( piles_temp$trtmnt_type[1] , &quot;\\nblock: &quot; , piles_temp$trtmnt_block[1] , &quot; | &quot; , piles_temp$trtmnt_unit[1] ) , fill = &quot;CHM (m)&quot; ) + ggplot2::theme_void() + ggplot2::theme( legend.position = &quot;bottom&quot; , legend.title = ggplot2::element_text(size = 6) , legend.text = ggplot2::element_text(size = 7) , plot.subtitle = ggplot2::element_text(size = 6, hjust = 0.5) ) }) # length(plts_temp) # plts_temp[[1]] # chm_rast %&gt;% # # terra::aggregate(fact = 2, fun=&quot;max&quot;,na.rm=T,cores=lasR::half_cores()) %&gt;% # terra::plot(col = viridis::plasma(n=100), main = &quot;CHM (m)&quot;, axes = F) # terra::plot( # stand_boundary %&gt;% terra::vect() # , add = T, border = &quot;black&quot;, col = NA, lwd = 1.5 # ) # terra::plot( # piles_workflow_ans %&gt;% # dplyr::filter(is_in_trtmnt_unit) %&gt;% # terra::vect() # , add = T, border = &quot;cyan&quot;, col = NA, lwd = 1.5 # ) heterogenous units wplts_temp &lt;- patchwork::wrap_plots( plts_temp[1:12] , ncol = 4 , guides = &quot;collect&quot; ) &amp; ggplot2::theme( legend.position = &quot;bottom&quot; # , legend.text = ggplot2::element_text(size = 7) ) # huh? wplts_temp uniform - high units wplts_temp &lt;- patchwork::wrap_plots( plts_temp[13:24] , ncol = 4 , guides = &quot;collect&quot; ) &amp; ggplot2::theme( legend.position = &quot;bottom&quot; # , legend.text = ggplot2::element_text(size = 7) ) # huh? wplts_temp uniform - low units wplts_temp &lt;- patchwork::wrap_plots( plts_temp[25:36] , ncol = 3 , guides = &quot;collect&quot; ) &amp; ggplot2::theme( legend.position = &quot;bottom&quot; # , legend.text = ggplot2::element_text(size = 7) ) # huh? wplts_temp let’s aggregate the detected slash pile information by treatment unit # hey pile_sum_temp &lt;- piles_workflow_ans %&gt;% sf::st_drop_geometry() %&gt;% dplyr::filter( is_in_trtmnt_unit , inrange_th_votes&gt;=5 ) %&gt;% dplyr::group_by( trtmnt_type,trtmnt_block,trtmnt_unit, trtmnt_unit_ha ) %&gt;% dplyr::summarize( n_piles = dplyr::n() , dplyr::across( .cols = c(area_m2, volume_m3) , .fns = list(mean = ~mean(.x,na.rm=T), sum = ~sum(.x,na.rm=T)) ) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate(piles_per_ha = n_piles/trtmnt_unit_ha) %&gt;% dplyr::arrange(trtmnt_type,trtmnt_block,trtmnt_unit ) table it by treatment unit pile_sum_temp %&gt;% dplyr::mutate( dplyr::across( .cols = c(n_piles, tidyselect::ends_with(&quot;_sum&quot;)) , .fns = ~scales::comma(.x,accuracy=1) ) , dplyr::across( .cols = c(trtmnt_unit_ha, piles_per_ha, tidyselect::ends_with(&quot;_mean&quot;)) , .fns = ~scales::comma(.x,accuracy=0.1) ) ) %&gt;% dplyr::relocate( trtmnt_type,trtmnt_block,trtmnt_unit, trtmnt_unit_ha , n_piles, piles_per_ha ) %&gt;% kableExtra::kbl( caption = &quot;slash pile quantity by treatment unit&quot; , col.names = c( &quot;type&quot;,&quot;block&quot;,&quot;unit&quot;,&quot;ha&quot; , &quot;# piles&quot;, &quot;piles ha&lt;sup&gt;-1&lt;/sup&gt;&quot; , &quot;mean pile&lt;br&gt;area (m&lt;sup&gt;2&lt;/sup&gt;)&quot; , &quot;tot. pile&lt;br&gt;area (m&lt;sup&gt;2&lt;/sup&gt;)&quot; , &quot;mean pile&lt;br&gt;bulk vol. (m&lt;sup&gt;3&lt;/sup&gt;)&quot; , &quot;tot. pile&lt;br&gt;bulk vol. (m&lt;sup&gt;3&lt;/sup&gt;)&quot; ) , escape = F # , digits = 2 ) %&gt;% kableExtra::kable_styling(font_size = 9.7) %&gt;% kableExtra::column_spec(seq(4,10,by=2), border_right = TRUE, include_thead = TRUE) %&gt;% kableExtra::collapse_rows(columns = 1, valign = &quot;top&quot;) %&gt;% kableExtra::scroll_box(height = &quot;8.4in&quot;) Table 3.1: slash pile quantity by treatment unit type block unit ha # piles piles ha-1 mean pilearea (m2) tot. pilearea (m2) mean pilebulk vol. (m3) tot. pilebulk vol. (m3) heterogenous 1 U40 9.1 464 50.9 7.1 3,306 5.8 2,676 2 U16 9.5 262 27.6 6.6 1,719 6.6 1,717 3 U26 9.0 382 42.6 7.2 2,733 6.7 2,570 4 U36 8.5 322 37.9 7.1 2,290 8.7 2,804 5 U39 8.3 442 53.2 7.7 3,385 7.0 3,108 6 U29 9.2 520 56.7 7.6 3,973 6.3 3,267 7 U44 8.6 181 21.0 5.3 967 8.5 1,535 8 U2 8.3 308 37.2 6.7 2,062 8.3 2,555 9 U53 8.4 325 38.5 6.9 2,240 4.6 1,492 10 U41 8.2 423 51.6 7.2 3,038 5.5 2,323 11 U43 8.1 434 53.4 7.3 3,174 5.5 2,383 12 U55 9.2 372 40.4 7.2 2,666 5.3 1,955 uniform- high 1 U10 5.2 320 61.8 8.9 2,861 5.5 1,754 2 U19 4.5 74 16.5 7.6 564 6.9 513 3 U18 4.1 112 27.3 6.9 778 6.3 707 4 U27 4.2 128 30.7 7.7 980 5.9 761 5 U37 5.6 128 22.8 6.7 859 8.1 1,043 6 U28 4.3 100 23.3 8.4 845 6.3 635 7 U45 4.3 46 10.7 4.7 215 6.2 284 8 U33 4.5 166 37.0 8.5 1,412 5.6 926 9 U52 4.1 208 50.7 9.2 1,913 6.0 1,254 10 U35 4.4 287 64.7 10.7 3,077 7.6 2,174 11 U49 4.4 220 50.1 8.7 1,919 5.8 1,278 12 U32 5.1 180 35.6 8.1 1,467 6.2 1,108 uniform- low 1 U10 5.2 317 61.3 8.9 2,827 5.5 1,737 2 U19 4.5 133 29.6 6.3 834 6.7 897 3 U18 4.1 111 27.0 5.8 645 7.6 843 4 U27 4.2 196 47.1 7.6 1,485 5.4 1,057 5 U37 5.6 244 43.4 8.1 1,988 7.4 1,795 6 U28 4.3 211 49.2 6.7 1,407 5.1 1,072 7 U45 4.3 63 14.7 6.1 384 9.0 566 8 U33 4.5 229 51.1 7.1 1,634 5.8 1,321 9 U52 4.1 193 47.1 7.9 1,525 5.1 978 10 U35 4.4 279 62.9 7.0 1,944 5.6 1,566 11 U49 4.4 209 47.6 8.3 1,731 5.2 1,097 12 U32 5.1 370 73.2 6.3 2,316 6.0 2,229 plot piles per ha by treatment unit pile_sum_temp %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( dplyr::across(c(trtmnt_type,trtmnt_block,trtmnt_unit),as.ordered) , my_fct = forcats::fct_cross(trtmnt_type,trtmnt_block,trtmnt_unit) ) %&gt;% dplyr::arrange(desc(trtmnt_type),piles_per_ha) %&gt;% dplyr::mutate(my_fct = forcats::fct_inorder(my_fct)) %&gt;% ggplot2::ggplot(mapping = ggplot2::aes(x=piles_per_ha,y=my_fct,fill=trtmnt_type,group = trtmnt_type)) + ggplot2::geom_col() + ggplot2::scale_fill_brewer(palette = &quot;Dark2&quot;) + ggplot2::scale_x_continuous(labels = scales::comma) + ggplot2::theme_light() + ggplot2::labs(x = &quot;piles per ha&quot;, y = &quot;&quot;) + ggplot2::theme( legend.position = &quot;none&quot; , axis.text.y = ggplot2::element_text(size = 7) , axis.text.x = ggplot2::element_text(size = 8) ) table it by treatment type pile_sum_temp %&gt;% dplyr::group_by(trtmnt_type) %&gt;% dplyr::summarise( dplyr::across( .cols = c(trtmnt_unit_ha, n_piles, tidyselect::ends_with(&quot;_sum&quot;)) , ~sum(.,na.rm = T) ) ) %&gt;% dplyr::mutate( area_m2_mean = area_m2_sum/n_piles , volume_m3_mean = volume_m3_sum/n_piles , piles_per_ha = n_piles/trtmnt_unit_ha ) %&gt;% dplyr::mutate( dplyr::across( .cols = c(n_piles, tidyselect::ends_with(&quot;_sum&quot;)) , .fns = ~scales::comma(.x,accuracy=1) ) , dplyr::across( .cols = c(trtmnt_unit_ha, piles_per_ha, tidyselect::ends_with(&quot;_mean&quot;)) , .fns = ~scales::comma(.x,accuracy=0.1) ) ) %&gt;% dplyr::select( trtmnt_type,trtmnt_unit_ha,n_piles , piles_per_ha , area_m2_mean,area_m2_sum , volume_m3_mean,volume_m3_sum ) %&gt;% kableExtra::kbl( caption = &quot;slash pile quantity by treatment type&quot; , col.names = c( &quot;type&quot;,&quot;ha&quot; , &quot;# piles&quot;, &quot;piles ha&lt;sup&gt;-1&lt;/sup&gt;&quot; , &quot;mean pile&lt;br&gt;area (m&lt;sup&gt;2&lt;/sup&gt;)&quot; , &quot;tot. pile&lt;br&gt;area (m&lt;sup&gt;2&lt;/sup&gt;)&quot; , &quot;mean pile&lt;br&gt;bulk vol. (m&lt;sup&gt;3&lt;/sup&gt;)&quot; , &quot;tot. pile&lt;br&gt;bulk vol. (m&lt;sup&gt;3&lt;/sup&gt;)&quot; ) , escape = F # , digits = 2 ) %&gt;% kableExtra::kable_styling(font_size = 10.1) %&gt;% kableExtra::column_spec(seq(2,8,by=2), border_right = TRUE, include_thead = TRUE) %&gt;% kableExtra::collapse_rows(columns = 1, valign = &quot;top&quot;) Table 3.2: slash pile quantity by treatment type type ha # piles piles ha-1 mean pilearea (m2) tot. pilearea (m2) mean pilebulk vol. (m3) tot. pilebulk vol. (m3) heterogenous 104.5 4,435 42.5 7.1 31,552 6.4 28,384 uniform- high 54.6 1,969 36.1 8.6 16,891 6.3 12,436 uniform- low 54.6 2,555 46.8 7.3 18,719 5.9 15,158 "],["treatment-unit-silvicultural-summary.html", "Section 4 Treatment Unit Silvicultural Summary 4.1 Remove Slash Piles 4.2 Function to Calculate Silviclutural Metrics 4.3 Treatment Unit Summaries", " Section 4 Treatment Unit Silvicultural Summary In this section, we’re going to aggregate the detected trees by treatment unit to produce silvicultural summaries. Before we do that, we’ll use pile predictions as a mask to remove smaller, detected “trees” that are actually piles or downed trees/debris so that we are only working with trees within units. 4.1 Remove Slash Piles read back in the tree point data and attach to treatment units treetops_sf &lt;- sf::st_read(dsn = treetops_fnm, quiet = TRUE) # attach to treatment unit treetops_sf &lt;- treetops_sf %&gt;% dplyr::inner_join( treetops_sf %&gt;% sf::st_transform(sf::st_crs(stand_boundary)) %&gt;% sf::st_intersection( stand_boundary %&gt;% dplyr::select(unit,block,tretmnt,unit_ha) %&gt;% dplyr::rename(type = tretmnt) %&gt;% dplyr::mutate( type = tolower(type) %&gt;% stringr::str_squish() ) %&gt;% dplyr::rename_with(.fn = ~paste0(&quot;trtmnt_&quot;, .x, recycle0 = T)) ) %&gt;% sf::st_drop_geometry() %&gt;% dplyr::select(treeID, tidyselect::starts_with(&quot;trtmnt_&quot;)) , by = &quot;treeID&quot; ) %&gt;% dplyr::mutate( is_in_trtmnt_unit = ifelse(is.na(trtmnt_type) | trtmnt_type==&quot;control&quot;,F,T) ) # treetops_sf %&gt;% dplyr::glimpse() use our slash pile mask to remove detected “trees” that are likely not trees. if a tree top point falls within the boundary of a detected pile footprint, it will be removed # save nrow nrow_temp &lt;- nrow(treetops_sf) treetops_sf &lt;- sf::st_filter( treetops_sf , piles_workflow_ans %&gt;% dplyr::filter(is_in_trtmnt_unit, inrange_th_votes&gt;=5) %&gt;% sf::st_union() , .predicate = sf::st_disjoint ) what proportion of “trees” were removed? # nrow_temp # nrow(treetops_sf) scales::percent((nrow_temp-nrow(treetops_sf))/nrow_temp, accuracy = 0.1) ## [1] &quot;2.7%&quot; nice. now we’ll keep only trees that are at least 2 m in height since we included trees as small as 1.37 m in our tree detection treetops_sf &lt;- treetops_sf %&gt;% dplyr::filter(tree_height_m&gt;=2) using our cleaned trees data, how many trees per treatment unit? treetops_sf %&gt;% sf::st_drop_geometry() %&gt;% dplyr::count(trtmnt_type, trtmnt_block, trtmnt_unit,trtmnt_unit_ha) %&gt;% dplyr::mutate( trees_per_ha = n/trtmnt_unit_ha , trtmnt_unit_ha = scales::comma(trtmnt_unit_ha,accuracy=0.1) , n = scales::comma(n,accuracy=1) , trees_per_ha = scales::comma(trees_per_ha,accuracy=0.1) ) %&gt;% kableExtra::kbl( caption = &quot;count trees by treatment unit&quot; , col.names = c( &quot;type&quot;,&quot;block&quot;,&quot;unit&quot;,&quot;ha&quot; , &quot;# trees&quot;, &quot;trees ha&lt;sup&gt;-1&lt;/sup&gt;&quot; ) , escape = F # , digits = 2 ) %&gt;% kableExtra::kable_styling(font_size = 9.7) %&gt;% kableExtra::column_spec(seq(4,6,by=2), border_right = TRUE, include_thead = TRUE) %&gt;% kableExtra::collapse_rows(columns = 1, valign = &quot;top&quot;) %&gt;% kableExtra::scroll_box(height = &quot;8.4in&quot;) Table 4.1: count trees by treatment unit type block unit ha # trees trees ha-1 control 1 U11 11.5 9,614 832.4 2 U23 10.3 10,443 1,013.1 3 U21 8.1 8,410 1,039.4 4 U4 6.7 6,417 958.8 5 U38 8.6 7,030 817.8 6 U30 10.1 10,692 1,055.2 7 U46 8.6 7,783 910.0 8 U31 8.1 7,378 912.4 9 U54 10.3 8,839 854.1 10 U42 8.3 6,306 755.6 11 U48 8.3 6,534 789.5 12 U34 9.2 9,752 1,055.5 heterogenous 1 U40 9.1 4,623 506.8 2 U16 9.5 5,576 586.6 3 U26 9.0 4,586 511.3 4 U36 8.5 4,014 472.0 5 U39 8.3 4,108 494.3 6 U29 9.2 5,487 598.2 7 U44 8.6 4,792 556.9 8 U2 8.3 4,327 522.2 9 U53 8.4 4,835 573.0 10 U41 8.2 4,475 545.7 11 U43 8.1 4,481 550.9 12 U55 9.2 5,556 603.6 uniform- high 1 U10 5.2 1,877 362.7 2 U19 4.5 1,339 298.1 3 U18 4.1 1,072 261.0 4 U27 4.2 1,746 419.3 5 U37 5.6 1,576 280.3 6 U28 4.3 999 232.8 7 U45 4.3 981 228.3 8 U33 4.5 863 192.4 9 U52 4.1 1,606 391.6 10 U35 4.4 1,036 233.5 11 U49 4.4 1,828 416.2 12 U32 5.1 978 193.6 uniform- low 1 U10 5.2 1,888 364.8 2 U19 4.5 2,458 547.2 3 U18 4.1 1,521 370.4 4 U27 4.2 1,921 461.3 5 U37 5.6 2,009 357.3 6 U28 4.3 1,784 415.7 7 U45 4.3 1,228 285.8 8 U33 4.5 1,630 363.4 9 U52 4.1 2,056 501.4 10 U35 4.4 2,033 458.3 11 U49 4.4 2,472 562.9 12 U32 5.1 2,176 430.8 where are these units in space? ggplot2::ggplot( data = stand_boundary , ggplot2::aes(color = ordered(block), fill = ordered(tolower(tretmnt))) )+ ggplot2::geom_sf(lwd = 2, alpha = 0.8) + ggplot2::scale_fill_brewer(palette = &quot;Dark2&quot;) + # ggplot2::scale_color_viridis_d(option = &quot;turbo&quot;) + ggplot2::scale_color_manual( values = viridis::turbo(n = length(unique(stand_boundary$block))) %&gt;% sample() ) + ggplot2::labs(fill = &quot;treatment\\ntype&quot;, color = &quot;treatment\\nblock&quot;) + ggplot2::theme_void() + ggplot2::guides( fill = ggplot2::guide_legend( override.aes = list( color = NA, shape = 15, linetype = 0, size = 6, alpha = 1 ) ) , color = ggplot2::guide_legend( override.aes = list( fill = NA, shape = 15, size = 6, alpha = 1 ) ) ) 4.2 Function to Calculate Silviclutural Metrics let’s make a function to summarize the data and create common silvicultural metrics within our stand boundary ################################################################################### # define a function to convert columns in data frame from metric to imperial # see: # https://www.forestnb.com/archives/forest-nb-news/resources/conversions/ # https://www.ars.usda.gov/is/np/agbyproducts/agbyappendix.pdf ################################################################################### calc_imperial_units_fn &lt;- function(df) { df %&gt;% # convert to imperial units dplyr::mutate( dplyr::across( .cols = tidyselect::ends_with(&quot;_cm&quot;) , ~ .x * 0.394 , .names = &quot;{.col}_in&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m&quot;) , ~ .x * 3.281 , .names = &quot;{.col}_ft&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m2_per_ha&quot;) , ~ .x * 4.359 , .names = &quot;{.col}_ftac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_kg_per_ha&quot;) , ~ .x * 0.892178 , .names = &quot;{.col}_lbsac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_per_ha&quot;) &amp; !tidyselect::ends_with(&quot;_m2_per_ha&quot;) &amp; !tidyselect::ends_with(&quot;_kg_per_ha&quot;) , ~ .x * 0.405 , .names = &quot;{.col}_ac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_area_ha&quot;) , ~ .x * 2.471 , .names = &quot;{.col}_ac&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;kg_per_m2&quot;) , ~ .x * 0.20482 , .names = &quot;{.col}_lbsft2&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;kg_per_m3&quot;) , ~ .x * 0.0624 , .names = &quot;{.col}_lbsft3&quot; ) , dplyr::across( .cols = tidyselect::ends_with(&quot;_m2&quot;) &amp; !tidyselect::ends_with(&quot;per_m2&quot;) , ~ .x * 10.764 , .names = &quot;{.col}_ft2&quot; ) ) %&gt;% dplyr::rename_with( .fn = function(x){dplyr::case_when( stringr::str_ends(x,&quot;_cm_in&quot;) ~ stringr::str_replace(x,&quot;_cm_in&quot;,&quot;_in&quot;) , stringr::str_ends(x,&quot;_m_ft&quot;) ~ stringr::str_replace(x,&quot;_m_ft&quot;,&quot;_ft&quot;) , stringr::str_ends(x,&quot;_m2_per_ha_ftac&quot;) ~ stringr::str_replace(x,&quot;_m2_per_ha_ftac&quot;,&quot;_ft2_per_ac&quot;) , stringr::str_ends(x,&quot;_kg_per_ha_lbsac&quot;) ~ stringr::str_replace(x,&quot;_kg_per_ha_lbsac&quot;,&quot;_lbs_per_ac&quot;) , stringr::str_ends(x,&quot;_per_ha_ac&quot;) ~ stringr::str_replace(x,&quot;_per_ha_ac&quot;,&quot;_per_ac&quot;) , stringr::str_ends(x,&quot;_area_ha_ac&quot;) ~ stringr::str_replace(x,&quot;_area_ha_ac&quot;,&quot;_area_ac&quot;) , stringr::str_ends(x,&quot;_kg_per_m2_lbsft2&quot;) ~ stringr::str_replace(x,&quot;_kg_per_m2_lbsft2&quot;,&quot;_lbs_per_ft2&quot;) , stringr::str_ends(x,&quot;_kg_per_m3_lbsft3&quot;) ~ stringr::str_replace(x,&quot;_kg_per_m3_lbsft3&quot;,&quot;_lbs_per_ft3&quot;) , stringr::str_ends(x,&quot;_m2_ft2&quot;) ~ stringr::str_replace(x,&quot;_m2_ft2&quot;,&quot;_ft2&quot;) , TRUE ~ x )} ) } ################################################################################### ### stand-level summaries ################################################################################### calc_silv_metrics &lt;- function(tree_list, stand_area_ha = NULL, study_boundary = NULL, calc_imperial_units = F) { # get study area if(!is.null(study_boundary)){ # bounds check if( !inherits(study_boundary,&quot;sf&quot;) &amp;&amp; !inherits(study_boundary,&quot;sfc&quot;) ){stop(&quot;study_boundary must be sf class object&quot;)} if(is.na(sf::st_crs(study_boundary))){stop(&quot;study_boundary does not have a CRS&quot;)} if(inherits(study_boundary,&quot;sf&quot;) &amp;&amp; nrow(study_boundary)!=1){ stop(&quot;study_boundary must only have a single record geometry&quot;) } if(inherits(study_boundary,&quot;sfc&quot;) &amp;&amp; length(study_boundary)!=1){ stop(&quot;study_boundary must only have a single record geometry&quot;) } if( !all( sf::st_is(study_boundary, c(&quot;POLYGON&quot;,&quot;MULTIPOLYGON&quot;)) ) ){ stop(&quot;study_boundary must contain POLYGON type geometry only&quot;) } # area xxstand_area_ha &lt;- study_boundary %&gt;% sf::st_area() %&gt;% as.numeric() %&gt;% `/`(10000) }else if(is.numeric(stand_area_ha)){ xxstand_area_ha &lt;- stand_area_ha[1] }else{ stop(&quot;must provide `stand_area_ha` as numeric or `study_boundary` as sf object&quot;) } if(is.null(xxstand_area_ha) || is.na(xxstand_area_ha) || dplyr::coalesce(xxstand_area_ha,0)&lt;=0){ stop(&quot;could not determine valid stand_area_ha&quot;) } # summarize tree list if(!inherits(tree_list,&quot;data.frame&quot;)){stop(&quot;tree_list must be data.frame class object&quot;)} ###### !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! NEED TO PUT IN CHECKS FOR COLUMNS USED # see: cloud2trees::check_df_cols_all_missing() if( !any(stringr::str_detect(names(tree_list), &quot;landfire_crown_biomass_kg&quot;)) ){ tree_list &lt;- tree_list %&gt;% dplyr::mutate(landfire_crown_biomass_kg=as.numeric(NA)) } if( !any(stringr::str_detect(names(tree_list), &quot;cruz_crown_biomass_kg&quot;)) ){ tree_list &lt;- tree_list %&gt;% dplyr::mutate(cruz_crown_biomass_kg=as.numeric(NA)) } if( !any(stringr::str_detect(names(tree_list), &quot;landfire_tree_kg_per_m3&quot;)) ){ tree_list &lt;- tree_list %&gt;% dplyr::mutate(landfire_tree_kg_per_m3=as.numeric(NA)) } if( !any(stringr::str_detect(names(tree_list), &quot;cruz_tree_kg_per_m3&quot;)) ){ tree_list &lt;- tree_list %&gt;% dplyr::mutate(cruz_tree_kg_per_m3=as.numeric(NA)) } # agg agg &lt;- tree_list %&gt;% sf::st_drop_geometry() %&gt;% dplyr::ungroup() %&gt;% dplyr::summarise( n_trees = dplyr::n() , mean_dbh_cm = mean(dbh_cm, na.rm = T) , mean_tree_height_m = mean(tree_height_m, na.rm = T) , mean_tree_cbh_m = mean(tree_cbh_m, na.rm = T) , loreys_height_m = sum(basal_area_m2*tree_height_m, na.rm = T) / sum(basal_area_m2, na.rm = T) , basal_area_m2 = sum(basal_area_m2, na.rm = T) , sum_dbh_cm_sq = sum(dbh_cm^2, na.rm = T) , landfire_crown_biomass_kg = sum(landfire_crown_biomass_kg, na.rm = F) , cruz_crown_biomass_kg = sum(cruz_crown_biomass_kg, na.rm = F) , mean_landfire_tree_kg_per_m3 = mean(landfire_tree_kg_per_m3, na.rm = T) , mean_cruz_tree_kg_per_m3 = mean(cruz_tree_kg_per_m3, na.rm = T) ) %&gt;% dplyr::ungroup() %&gt;% dplyr::mutate( stand_area_ha = xxstand_area_ha , trees_per_ha = (n_trees/stand_area_ha) , basal_area_m2_per_ha = (basal_area_m2/stand_area_ha) , qmd_cm = sqrt(sum_dbh_cm_sq/n_trees) , landfire_cfl_kg_per_m2 = landfire_crown_biomass_kg/(stand_area_ha*10000) , cruz_cfl_kg_per_m2 = cruz_crown_biomass_kg/(stand_area_ha*10000) ) %&gt;% dplyr::select(-c(sum_dbh_cm_sq,landfire_crown_biomass_kg,cruz_crown_biomass_kg)) # imperial if(calc_imperial_units){ agg &lt;- calc_imperial_units_fn(agg) } return(agg) } check out the data structure returned by the calc_silv_metrics() function calc_silv_metrics( tree_list = treetops_sf %&gt;% # just get one unit dplyr::filter( trtmnt_type==treetops_sf$trtmnt_type[1] , trtmnt_block==treetops_sf$trtmnt_block[1] , trtmnt_unit==treetops_sf$trtmnt_unit[1] ) , stand_area_ha = treetops_sf$trtmnt_unit_ha[1] , calc_imperial_units = T ) %&gt;% dplyr::glimpse() ## Rows: 1 ## Columns: 27 ## $ n_trees &lt;int&gt; 10443 ## $ mean_dbh_cm &lt;dbl&gt; 24.03183 ## $ mean_tree_height_m &lt;dbl&gt; 4.395676 ## $ mean_tree_cbh_m &lt;dbl&gt; 2.120214 ## $ loreys_height_m &lt;dbl&gt; 5.319859 ## $ basal_area_m2 &lt;dbl&gt; 534.4338 ## $ mean_landfire_tree_kg_per_m3 &lt;dbl&gt; 0.6795806 ## $ mean_cruz_tree_kg_per_m3 &lt;dbl&gt; 1.15825 ## $ stand_area_ha &lt;dbl&gt; 10.30788 ## $ trees_per_ha &lt;dbl&gt; 1013.108 ## $ basal_area_m2_per_ha &lt;dbl&gt; 51.8471 ## $ qmd_cm &lt;dbl&gt; 25.52639 ## $ landfire_cfl_kg_per_m2 &lt;dbl&gt; 0.4942284 ## $ cruz_cfl_kg_per_m2 &lt;dbl&gt; NA ## $ mean_dbh_in &lt;dbl&gt; 9.468542 ## $ qmd_in &lt;dbl&gt; 10.0574 ## $ mean_tree_height_ft &lt;dbl&gt; 14.42221 ## $ mean_tree_cbh_ft &lt;dbl&gt; 6.956424 ## $ loreys_height_ft &lt;dbl&gt; 17.45446 ## $ basal_area_ft2_per_ac &lt;dbl&gt; 226.0015 ## $ trees_per_ac &lt;dbl&gt; 410.3088 ## $ stand_area_ac &lt;dbl&gt; 25.47078 ## $ landfire_cfl_lbs_per_ft2 &lt;dbl&gt; 0.1012279 ## $ cruz_cfl_lbs_per_ft2 &lt;dbl&gt; NA ## $ mean_landfire_tree_lbs_per_ft3 &lt;dbl&gt; 0.04240583 ## $ mean_cruz_tree_lbs_per_ft3 &lt;dbl&gt; 0.07227478 ## $ basal_area_ft2 &lt;dbl&gt; 5752.645 4.3 Treatment Unit Summaries let’s summarize the tree data by treatment unit unit_sum_df &lt;- treetops_sf %&gt;% sf::st_drop_geometry() %&gt;% dplyr::distinct(trtmnt_type,trtmnt_block,trtmnt_unit,trtmnt_unit_ha) unit_sum_df &lt;- 1:nrow(unit_sum_df) %&gt;% purrr::map(function(x){ unit_temp &lt;- unit_sum_df %&gt;% dplyr::slice(x) unit_temp %&gt;% dplyr::bind_cols( calc_silv_metrics( tree_list = treetops_sf %&gt;% # just get one unit dplyr::inner_join( unit_temp , by = dplyr::join_by(trtmnt_type,trtmnt_block,trtmnt_unit) ) , stand_area_ha = unit_temp$trtmnt_unit_ha , calc_imperial_units = T ) ) }) %&gt;% dplyr::bind_rows() %&gt;% dplyr::mutate( dplyr::across(c(trtmnt_type,trtmnt_block,trtmnt_unit),ordered) , my_fct = forcats::fct_cross(trtmnt_type,trtmnt_block,trtmnt_unit) ) %&gt;% dplyr::arrange(desc(trtmnt_type),trees_per_ha) %&gt;% dplyr::mutate(my_fct = forcats::fct_inorder(my_fct)) # unit_sum_df %&gt;% dplyr::glimpse() 4.3.1 Tabular 4.3.1.1 Metric units unit_sum_df %&gt;% dplyr::arrange(trtmnt_type, trtmnt_block, trtmnt_unit) %&gt;% dplyr::select( trtmnt_type, trtmnt_block, trtmnt_unit , stand_area_ha # different , n_trees , trees_per_ha , mean_tree_height_m , loreys_height_m , mean_dbh_cm , qmd_cm , basal_area_m2_per_ha , mean_landfire_tree_kg_per_m3 , mean_cruz_tree_kg_per_m3 ) %&gt;% dplyr::mutate( dplyr::across(c(n_trees), ~scales::comma(.x,accuracy=1)) , dplyr::across( -c(tidyselect::starts_with(&quot;trtmnt_&quot;),n_trees,tidyselect::ends_with(&quot;3&quot;)) , ~scales::comma(.x,accuracy=0.1) ) , dplyr::across( tidyselect::ends_with(&quot;3&quot;) , ~scales::comma(.x,accuracy=0.001) ) ) %&gt;% kableExtra::kbl( caption = &quot;Stand summary metrics in metric units&quot; , col.names = c( &quot;type&quot;,&quot;block&quot;,&quot;unit&quot;,&quot;ha&quot; , &quot;trees&quot; , &quot;trees ha&lt;sup&gt;-1&lt;/sup&gt;&quot; , &quot;mean&lt;br&gt;tree ht. (m)&quot; , &quot;Lorey&#39;s&lt;br&gt;tree ht. (m)&quot; , &quot;mean&lt;br&gt;DBH (cm)&quot; , &quot;QMD (cm)&quot; , &quot;BA (m&lt;sup&gt;2&lt;/sup&gt; ha&lt;sup&gt;-1&lt;/sup&gt;)&quot; , &quot;mean&lt;br&gt;CBD (kg m&lt;sup&gt;-3&lt;/sup&gt;)&lt;br&gt;LANDFIRE&quot; , &quot;mean&lt;br&gt;CBD (kg m&lt;sup&gt;-3&lt;/sup&gt;)&lt;br&gt;Cruz&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling(font_size = 9.7) %&gt;% # kableExtra::column_spec(seq(4,10,by=2), border_right = TRUE, include_thead = TRUE) %&gt;% kableExtra::collapse_rows(columns = 1, valign = &quot;top&quot;) %&gt;% kableExtra::scroll_box(height = &quot;8.4in&quot;) Table 4.2: Stand summary metrics in metric units type block unit ha trees trees ha-1 meantree ht. (m) Lorey’stree ht. (m) meanDBH (cm) QMD (cm) BA (m2 ha-1) meanCBD (kg m-3)LANDFIRE meanCBD (kg m-3)Cruz control 1 U11 11.5 9,614 832.4 4.2 4.9 23.0 24.2 38.4 0.664 NA 2 U23 10.3 10,443 1,013.1 4.4 5.3 24.0 25.5 51.8 0.680 1.158 3 U21 8.1 8,410 1,039.4 4.2 4.9 23.5 24.7 49.9 0.508 0.982 4 U4 6.7 6,417 958.8 4.2 5.1 22.7 24.3 44.3 0.642 1.044 5 U38 8.6 7,030 817.8 4.2 5.0 23.3 24.5 38.6 0.423 0.626 6 U30 10.1 10,692 1,055.2 4.2 4.8 23.2 24.3 48.9 0.508 NA 7 U46 8.6 7,783 910.0 4.6 5.5 25.1 26.5 50.1 0.560 NA 8 U31 8.1 7,378 912.4 4.6 5.4 25.1 26.4 49.8 0.562 NA 9 U54 10.3 8,839 854.1 4.5 5.3 25.2 26.4 46.8 0.681 NA 10 U42 8.3 6,306 755.6 4.1 5.0 22.6 24.1 34.3 0.663 NA 11 U48 8.3 6,534 789.5 4.3 5.2 23.8 25.3 39.6 0.713 NA 12 U34 9.2 9,752 1,055.5 3.8 4.4 20.6 21.7 39.0 0.664 NA heterogenous 1 U40 9.1 4,623 506.8 4.6 5.3 25.3 26.6 28.1 0.921 NA 2 U16 9.5 5,576 586.6 4.7 5.5 25.9 27.2 34.0 0.981 1.054 3 U26 9.0 4,586 511.3 4.8 5.7 25.9 27.4 30.1 0.859 0.906 4 U36 8.5 4,014 472.0 4.5 5.3 24.9 26.1 25.3 0.764 0.787 5 U39 8.3 4,108 494.3 4.7 5.4 26.4 27.4 29.1 0.850 0.909 6 U29 9.2 5,487 598.2 4.5 5.1 25.1 26.1 32.1 0.777 NA 7 U44 8.6 4,792 556.9 4.4 5.0 24.5 25.6 28.6 0.965 NA 8 U2 8.3 4,327 522.2 4.8 5.5 26.4 27.5 30.9 0.964 NA 9 U53 8.4 4,835 573.0 4.3 5.0 24.1 25.2 28.6 1.015 NA 10 U41 8.2 4,475 545.7 4.9 5.6 26.9 28.1 33.8 0.874 0.699 11 U43 8.1 4,481 550.9 4.7 5.4 26.0 27.2 31.9 0.972 NA 12 U55 9.2 5,556 603.6 4.4 5.0 24.6 25.6 31.2 0.936 NA uniform- high 1 U10 5.2 1,877 362.7 4.9 5.4 27.1 28.1 22.4 1.104 NA 2 U19 4.5 1,339 298.1 4.9 5.6 26.7 28.0 18.4 0.990 1.166 3 U18 4.1 1,072 261.0 4.5 5.4 24.5 26.0 13.9 0.973 1.010 4 U27 4.2 1,746 419.3 5.2 5.8 28.6 29.5 28.7 1.166 1.072 5 U37 5.6 1,576 280.3 5.2 6.0 28.2 29.4 19.0 1.022 0.838 6 U28 4.3 999 232.8 4.9 5.5 27.1 28.1 14.5 1.046 NA 7 U45 4.3 981 228.3 5.1 5.8 28.2 29.3 15.4 0.955 NA 8 U33 4.5 863 192.4 4.8 5.3 26.8 27.6 11.5 1.076 NA 9 U52 4.1 1,606 391.6 4.7 5.2 26.4 27.3 22.9 1.238 1.123 10 U35 4.4 1,036 233.5 4.7 5.2 26.2 27.1 13.5 1.009 1.184 11 U49 4.4 1,828 416.2 5.2 5.7 28.7 29.6 28.6 1.179 NA 12 U32 5.1 978 193.6 4.7 5.4 26.4 27.4 11.4 1.090 NA uniform- low 1 U10 5.2 1,888 364.8 4.4 5.0 24.8 25.8 19.1 1.011 0.973 2 U19 4.5 2,458 547.2 4.9 5.6 26.9 28.1 33.9 1.105 1.330 3 U18 4.1 1,521 370.4 4.5 5.1 24.9 26.0 19.6 1.129 0.924 4 U27 4.2 1,921 461.3 4.8 5.5 26.8 27.9 28.2 1.089 1.100 5 U37 5.6 2,009 357.3 4.5 5.0 25.3 26.2 19.3 0.957 0.534 6 U28 4.3 1,784 415.7 4.7 5.3 26.2 27.2 24.2 1.118 NA 7 U45 4.3 1,228 285.8 5.0 5.7 27.6 28.6 18.4 1.110 NA 8 U33 4.5 1,630 363.4 4.5 5.1 25.5 26.4 19.9 1.057 NA 9 U52 4.1 2,056 501.4 4.6 5.1 25.7 26.6 27.8 1.282 NA 10 U35 4.4 2,033 458.3 4.8 5.5 26.6 27.8 27.8 1.021 1.392 11 U49 4.4 2,472 562.9 4.9 5.6 27.3 28.3 35.4 1.043 NA 12 U32 5.1 2,176 430.8 4.4 5.0 24.4 25.4 21.9 1.022 NA 4.3.1.2 Imperial units unit_sum_df %&gt;% dplyr::arrange(trtmnt_type, trtmnt_block, trtmnt_unit) %&gt;% dplyr::select( trtmnt_type, trtmnt_block, trtmnt_unit , stand_area_ac # different , n_trees , trees_per_ac , mean_tree_height_ft , loreys_height_ft , mean_dbh_in , qmd_in , basal_area_ft2_per_ac , mean_landfire_tree_lbs_per_ft3 , mean_cruz_tree_lbs_per_ft3 ) %&gt;% dplyr::mutate( dplyr::across(c(n_trees), ~scales::comma(.x,accuracy=1)) , dplyr::across( -c(n_trees,tidyselect::starts_with(&quot;trtmnt_&quot;),tidyselect::ends_with(&quot;3&quot;)) , ~scales::comma(.x,accuracy=0.1) ) , dplyr::across( tidyselect::ends_with(&quot;3&quot;) , ~scales::comma(.x,accuracy=0.001) ) ) %&gt;% kableExtra::kbl( caption = &quot;Stand summary metrics in imperial units&quot; , col.names = c( &quot;type&quot;,&quot;block&quot;,&quot;unit&quot;,&quot;ac&quot; , &quot;trees&quot; , &quot;trees ac&lt;sup&gt;-1&lt;/sup&gt;&quot; , &quot;mean&lt;br&gt;tree ht. (ft)&quot; , &quot;Lorey&#39;s&lt;br&gt;tree ht. (ft)&quot; , &quot;mean&lt;br&gt;DBH (in)&quot; , &quot;QMD (in)&quot; , &quot;BA (ft&lt;sup&gt;2&lt;/sup&gt; ac&lt;sup&gt;-1&lt;/sup&gt;)&quot; , &quot;mean&lt;br&gt;CBD (lb ft&lt;sup&gt;-3&lt;/sup&gt;)&lt;br&gt;LANDFIRE&quot; , &quot;mean&lt;br&gt;CBD (lb ft&lt;sup&gt;-3&lt;/sup&gt;)&lt;br&gt;Cruz&quot; ) , escape = F ) %&gt;% kableExtra::kable_styling(font_size = 9.7) %&gt;% # kableExtra::column_spec(seq(4,10,by=2), border_right = TRUE, include_thead = TRUE) %&gt;% kableExtra::collapse_rows(columns = 1, valign = &quot;top&quot;) %&gt;% kableExtra::scroll_box(height = &quot;8.4in&quot;) Table 4.3: Stand summary metrics in imperial units type block unit ac trees trees ac-1 meantree ht. (ft) Lorey’stree ht. (ft) meanDBH (in) QMD (in) BA (ft2 ac-1) meanCBD (lb ft-3)LANDFIRE meanCBD (lb ft-3)Cruz control 1 U11 28.5 9,614 337.1 13.6 16.1 9.0 9.5 167.3 0.041 NA 2 U23 25.5 10,443 410.3 14.4 17.5 9.5 10.1 226.0 0.042 0.072 3 U21 20.0 8,410 420.9 13.9 16.2 9.3 9.7 217.4 0.032 0.061 4 U4 16.5 6,417 388.3 13.6 16.8 8.9 9.6 193.1 0.040 0.065 5 U38 21.2 7,030 331.2 13.8 16.3 9.2 9.7 168.4 0.026 0.039 6 U30 25.0 10,692 427.4 13.7 15.8 9.1 9.6 213.1 0.032 NA 7 U46 21.1 7,783 368.5 15.0 17.9 9.9 10.4 218.5 0.035 NA 8 U31 20.0 7,378 369.5 15.0 17.7 9.9 10.4 217.1 0.035 NA 9 U54 25.6 8,839 345.9 14.9 17.3 9.9 10.4 204.2 0.042 NA 10 U42 20.6 6,306 306.0 13.5 16.3 8.9 9.5 149.7 0.041 NA 11 U48 20.5 6,534 319.7 14.2 17.1 9.4 10.0 172.8 0.045 NA 12 U34 22.8 9,752 427.5 12.3 14.4 8.1 8.5 170.0 0.041 NA heterogenous 1 U40 22.5 4,623 205.3 15.0 17.5 10.0 10.5 122.6 0.058 NA 2 U16 23.5 5,576 237.6 15.5 18.2 10.2 10.7 148.4 0.061 0.066 3 U26 22.2 4,586 207.1 15.6 18.7 10.2 10.8 131.3 0.054 0.057 4 U36 21.0 4,014 191.1 14.8 17.4 9.8 10.3 110.4 0.048 0.049 5 U39 20.5 4,108 200.2 15.5 17.6 10.4 10.8 127.0 0.053 0.057 6 U29 22.7 5,487 242.3 14.7 16.8 9.9 10.3 139.8 0.048 NA 7 U44 21.3 4,792 225.5 14.4 16.4 9.7 10.1 124.8 0.060 NA 8 U2 20.5 4,327 211.5 15.6 17.9 10.4 10.8 134.8 0.060 NA 9 U53 20.9 4,835 232.1 14.2 16.4 9.5 9.9 124.9 0.063 NA 10 U41 20.3 4,475 221.0 16.0 18.3 10.6 11.1 147.3 0.055 0.044 11 U43 20.1 4,481 223.1 15.4 17.7 10.2 10.7 139.1 0.061 NA 12 U55 22.7 5,556 244.4 14.4 16.4 9.7 10.1 135.8 0.058 NA uniform- high 1 U10 12.8 1,877 146.9 15.9 17.8 10.7 11.1 97.7 0.069 NA 2 U19 11.1 1,339 120.7 15.9 18.5 10.5 11.0 80.0 0.062 0.073 3 U18 10.1 1,072 105.7 14.7 17.9 9.6 10.3 60.5 0.061 0.063 4 U27 10.3 1,746 169.8 17.0 19.1 11.3 11.6 125.2 0.073 0.067 5 U37 13.9 1,576 113.5 17.1 19.7 11.1 11.6 82.7 0.064 0.052 6 U28 10.6 999 94.3 16.0 18.1 10.7 11.1 63.1 0.065 NA 7 U45 10.6 981 92.5 16.8 19.0 11.1 11.5 67.0 0.060 NA 8 U33 11.1 863 77.9 15.6 17.2 10.5 10.9 50.1 0.067 NA 9 U52 10.1 1,606 158.6 15.4 17.2 10.4 10.8 100.0 0.077 0.070 10 U35 11.0 1,036 94.6 15.3 17.1 10.3 10.7 58.8 0.063 0.074 11 U49 10.9 1,828 168.6 17.0 18.9 11.3 11.6 124.6 0.074 NA 12 U32 12.5 978 78.4 15.5 17.6 10.4 10.8 49.9 0.068 NA uniform- low 1 U10 12.8 1,888 147.8 14.5 16.4 9.8 10.2 83.2 0.063 0.061 2 U19 11.1 2,458 221.6 16.0 18.3 10.6 11.1 147.7 0.069 0.083 3 U18 10.1 1,521 150.0 14.6 16.7 9.8 10.2 85.5 0.070 0.058 4 U27 10.3 1,921 186.8 15.9 18.2 10.6 11.0 122.8 0.068 0.069 5 U37 13.9 2,009 144.7 14.7 16.4 10.0 10.3 84.1 0.060 0.033 6 U28 10.6 1,784 168.4 15.4 17.4 10.3 10.7 105.4 0.070 NA 7 U45 10.6 1,228 115.8 16.5 18.7 10.9 11.3 80.2 0.069 NA 8 U33 11.1 1,630 147.2 14.9 16.6 10.1 10.4 86.9 0.066 NA 9 U52 10.1 2,056 203.1 15.0 16.7 10.1 10.5 121.3 0.080 NA 10 U35 11.0 2,033 185.6 15.8 18.1 10.5 10.9 121.1 0.064 0.087 11 U49 10.9 2,472 228.0 16.2 18.5 10.7 11.2 154.5 0.065 NA 12 U32 12.5 2,176 174.5 14.3 16.2 9.6 10.0 95.3 0.064 NA 4.3.2 Visual we’ll start with a simple bar plot to see if the aggregated trees per ha generally align with the treatment types unit_sum_df %&gt;% ggplot2::ggplot(mapping = ggplot2::aes(x=trees_per_ha,y=my_fct,fill=trtmnt_type,group = trtmnt_type)) + ggplot2::geom_col() + ggplot2::scale_fill_brewer(palette = &quot;Dark2&quot;) + ggplot2::scale_x_continuous(labels = scales::comma) + ggplot2::theme_light() + ggplot2::labs(x = &quot;trees per ha&quot;, y = &quot;&quot;) + ggplot2::theme( legend.position = &quot;none&quot; , axis.text.y = ggplot2::element_text(size = 7) , axis.text.x = ggplot2::element_text(size = 8) ) that’s looks about right, let’s check out a unit-level distribution of the TPH # reusable function for plotting plt_metric_dist_fn &lt;- function(df, metric_name, metric_label = NA) { if(any(is.na(metric_label))){metric_label &lt;- metric_name} tit &lt;- paste( &quot;distribution of treatment unit&quot; ,metric_label ) %&gt;% latex2exp::TeX() df %&gt;% ggplot2::ggplot(mapping = ggplot2::aes(x=.data[[metric_name]],fill=trtmnt_type)) + ggplot2::geom_density(mapping = ggplot2::aes(y=ggplot2::after_stat(scaled)), alpha = 0.8, color = NA) + ggplot2::facet_grid( rows = dplyr::vars(trtmnt_type) , axes = &quot;all&quot; , switch = &quot;y&quot; ) + ggplot2::scale_fill_brewer(palette = &quot;Dark2&quot;) + ggplot2::scale_x_continuous(limits=c(0,NA),labels = scales::comma) + ggplot2::scale_y_continuous(NULL,breaks=NULL) + ggplot2::labs( fill=&quot;&quot;,x=latex2exp::TeX(metric_label),y=&quot;&quot; , title = tit , subtitle = &quot;\\nby treatment type&quot; ) + ggplot2::theme_light() + ggplot2::theme( legend.position = &quot;none&quot; , strip.text = ggplot2::element_text(size = 10, color = &quot;black&quot;, face = &quot;bold&quot;) , axis.text.x = ggplot2::element_text(size = 9) , plot.subtitle = ggplot2::element_text(margin = margin(t = -10, unit = &quot;pt&quot;)) ) } plt_metric_violin_fn &lt;- function(df, metric_name, metric_label = NA) { if(any(is.na(metric_label))){metric_label &lt;- metric_name} tit &lt;- paste( &quot;distribution of treatment unit&quot; ,metric_label ) %&gt;% latex2exp::TeX() df %&gt;% ggplot2::ggplot(mapping = ggplot2::aes(x=.data[[metric_name]])) + ggplot2::geom_violin( mapping = ggplot2::aes(y = 0, fill=trtmnt_type) , alpha = 0.8, color = NA ) + ggplot2::geom_boxplot(width = 0.1, fill = NA, outliers = F) + ggplot2::facet_grid( rows = dplyr::vars(trtmnt_type) , axes = &quot;all&quot; , switch = &quot;y&quot; ) + ggplot2::scale_fill_brewer(palette = &quot;Dark2&quot;) + ggplot2::scale_x_continuous(limits=c(0,NA),labels = scales::comma) + ggplot2::scale_y_continuous(NULL,breaks=NULL) + ggplot2::labs( fill=&quot;&quot;,x=latex2exp::TeX(metric_label),y=&quot;&quot; , title = tit , subtitle = &quot;\\nby treatment type&quot; ) + ggplot2::theme_light() + ggplot2::theme( legend.position = &quot;none&quot; , strip.text = ggplot2::element_text(size = 10, color = &quot;black&quot;, face = &quot;bold&quot;) , axis.text.x = ggplot2::element_text(size = 9) , plot.subtitle = ggplot2::element_text(margin = margin(t = -10, unit = &quot;pt&quot;)) ) } # plot it plt_metric_violin_fn(unit_sum_df,&quot;trees_per_ha&quot;,metric_label = &quot;trees $ha^{-1}$&quot;) # plt_metric_dist_fn(unit_sum_df,&quot;trees_per_ha&quot;,metric_label = &quot;trees $ha^{-1}$&quot;) since we also have imperial units let’s see TPA plt_metric_violin_fn(unit_sum_df,&quot;trees_per_ac&quot;,metric_label = &quot;trees $ac^{-1}$&quot;) we can also look at the QMD in cm plt_metric_violin_fn(unit_sum_df,&quot;qmd_cm&quot;,metric_label = &quot;QMD (cm)&quot;) and QMD in inches plt_metric_violin_fn(unit_sum_df,&quot;qmd_in&quot;,metric_label = &quot;QMD (in)&quot;) and basal area in square meters per hectare plt_metric_violin_fn(unit_sum_df,&quot;basal_area_m2_per_ha&quot;,metric_label = &quot;basal area ($m^{2} ha^{-1}$)&quot;) but also basal area in square feet per acre plt_metric_violin_fn(unit_sum_df,&quot;basal_area_ft2_per_ac&quot;,metric_label = &quot;basal area ($ft^{2} ac^{-1}$)&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
